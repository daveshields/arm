-title mincod						: phase 2 translation from minimal tokens to 80386 code
-stitl description

* use # as start of line for full-line comment
* use // for rest of line comment
* registers are $n or $rn
* can also use @ for end-line comment
* use directive  .syntax unified


*	Copyright 1987-2012 robert b. k. dewar and mark emmer.
*	Copyright 2012-2017 david shields

*	this file is part of macro spitbol.

*	macro spitbol is free software: you can redistribute it and/or modify
*	it under the terms of the gnu general public license as published by
*	the free software foundation, either version 2 of the license, or
*	(at your option) any later version.

*	macro spitbol is distributed in the hope that it will be useful,
*	but without any warranty; without even the implied warranty of
*	merchantability or fitness for a particular purpose.  see the
*	gnu general public license for more details.

*	you should have received a copy of the gnu general public license
*	along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.


*	this program takes input file in minimal token form and produces assembly
*	code for intel x64 processor. the program obtains the name of the file
*	to be translated from the command line string in host(0).

*	options relating to the processing of comments can be changed
*	by modifying the source.

*	In addition to the minimal token file, the program requires the name
*	of a "machine definition file" that contains code specific to a
*	particular 80386 assembler.

*	you may also specify option flags on the command line to control the
*	code generation.  the following flags are processed:

*	    compress	    generate tabs rather than spaces in output file
*	    comments	    retain full-line and end-of-line comments

*	the variable arch is set equal to the uppercase name of the machine
*	being processed. specific tests upon this variable are discouraged,
*	as all machine-dependent code should be placed in the machine-definition
*	file if possible.

*	in addition to the normal minimal register complement, one scratch work
*	register, w0 is defined. see the register map below for specific allocations.

*	this program is based in part on earlier translators for the it is based in part on
*	earlier translators for the dec vax (vms and un*x) written by steve duff and
*	robert goldberg, and the pc-spitbol translator written by david shields.

*  to run under spitbol:

*	    spitbol -u "<file>:<machine>[:flag:...:flag]" codlinux.spt

*	    reads <file>.lex	    containing tokenized source code
*	    writes <file>.s	    with 80386 assembly code
*	    also writes <file>.err  with err and erb error messages
*	    parts of m.hdr  are prepended and appended to <file>.s
*	    also sets flags	    to 1 after converting names to upper case
*	    also reads <file>.pub   for debug symbols to be declared public

*	example:


*	    spitbol -u v37:dos:compress codlinux.spt


*	error is used to report an error for current statement

-stitl crack(line)
	define('crack(line)operands,operand,char')	:(crack.end)

*	crack is called to create a stmt plex containing the various parts of the minimal source
*	statement in line.  for conditional assembly ops, the opcode is the op, and op1 is the symbol.
*	note that dtc is handled as a special case to assure that the decomposition is correct.

*	crack prints an error and fails if a syntax error occurs.



*	crack parses stmt into a stmt data plex and returns it. it fails if there is a syntax error.

crack

	nstmts	= nstmts + 1
	op1 = op2 = op3 = typ1 = typ2 = typ3 =
	line	p.csparse				:s(return)
*	here on syntax error

	error('source line syntax error')		:(freturn)
crack.end
-stitl	chktrace()
	define('chktrace()')				:(chktrace_end)
chktrace

*						     :(return)
*	     output = 'chktrace:' iinput_lines ':' label ':' stmtout
*	     output = differ (label) 'chktrace label:' label ':'
*	     turn off skip mode when begin executable code

	clabel = inlabel
	old_z_skip = z_skip
	old_z_exec = z_exec
	old_is_exec = is_exec
	z_skip = ident(inlabel,'s_aaa') 0

*	     incode ? any(lcase)		     :s(return)

	uopcode	 = replace(incode, lcase,ucase)

*	do not trace bsw (for now)

	ident(uopcode,'bsw')				:s(return)
	is_exec = is_executable[uopcode]
	z_exec = ne(z_trace)  ident(inlabel, 's_aaa') 1
	z_exec = gt(input_lines,2186) 1

*	need to skip certain blocks since otherwise get branches that are
*	too long skip when in code that won't assemble if try to trace
*	this was discovered on a case-by-case basis.

	z_skip	= differ(inlabel) differ(skip_on[inlabel]) 1
	z_skip	= differ(inlabel) differ(skip_off[inlabel]) 0

	ne(z_skip)					:s(return)
	eq(z_exec)					:s(return)
	eq(is_exec)					:s(return)

*	here to emit trace. need to emit trace after label if there is label
*	ident(inlabel)			     :s(chktrace.1)
*	     only trace at labels since get jumps that are too removed otherwise
*	     ident(label)			     :s(return)
*	     here to emit trace code when there is label
*	     first need to emit label, then fall through

*	     stmtout ? break_ws	 . label spanws	 rem . body  :f(outstmt5)
*	     stmtout = tab body
*	     outfile = label
*	     label =
	ne(in_gcol)					:s(return)

chktrace.1

	genz()
							:(return)

chktrace_end
-stitl	flush
	define('flush()')				:(flush_end)

*	here to emit  attach input label and comment to first instruction generated.

flush

** This should be no-op since genaop, genbop and gencop used inx x65 implementation no longer needed. 

							:(return)

*	here if some statements to emit, so output single 'null' statement 
*	to get label and comment field right.

	label = thislabel =
	outstmt(tstmt())				:(return)

flush_0

flush_end
-stitl define('genrep(op)
	define('genrep(op)l1,l2)')			:(genrep_end)

*	generate code to repeat operation *op* using
*	'rep *op* loop' instruction.

genrep
	l1 = genlab()
	l2 = genlab()
	genopl(l1 '					:')
	genop('or',wa,wa)
	genop('jz',l2)
	genop(op)
	genop('dec',wa)
	genop('jmp',l1)
	genopl(l2 '					:')
							:(return)
genrep_end
-stitl genz
	define('genz()')				:(genz_end)

*	generate trace instruction if needed.

genz

*	     no trace if trace has been suspended
*	     output = ne(z_suspend) 'z_suspend ' thisline

	ne(z_suspend)					:s(return)

*  only trace at label definition
*	     ident(thislabel)			     :s(return)

	z_count = z_count + 1
	gt(z_first) le(z_count,z_first)			:s(return)
	gt(z_limit)  gt(z_count, z_limit)		:s(return)

*	     always generate trace if at label definition

	z_desc = '"' replace(thisline,sepchar,' ') '"'
	outfile = tab 'zzz' tab z_count ',' input_lines ',' z_desc
	outlines = outlines + 1
							:(return)

genz_end
-stitl comregs(line)t,pre,word
	define('comregs(line)t,pre,word')		:(comregs_end)

*	map minimal register names to target register names

comregs

	line p.comregs =				:f(comregs1)
	word = eq(size(word),2) differ(t = word) t
	comregs = comregs pre word			:(comregs)

comregs1 comregs = comregs line				:(return)

comregs_end
-stitl error(text)
	define('error(text)')				:(error_end)

*	this module handles reporting of errors with the offending
*	statement text in thisline.  comments explaining
*	the error are written to the listing (including error chain), and
*	the appropriate counts are updated.

error

	outfile = filenami ': error: ' text
	outfile = rpad(lpad(input_lines,6),size(filenami) -1) ' | ' thisline
	lasterror = output_lines
	output_lines = output_lines + 2
	le(nerrors = nerrors + 1, 10)			:s(opnext)
	output = 'too many errors, quitting'		:(end)

error_end
-stitl	fetch(argnum)
	define('fetch(reg,iarg)iarg,t1,t2')		:(fetch_end)

*	get argument to register _reg_ and return that register.

fetch

	convert(iarg,'integer') genop('ldr',reg,const(convert(iarg,'integer'))) :s(return)
*	iarg = eq(argnum,1) arg1
*	iarg = eq(argnum,2) arg2
*	iarg = eq(argnum,3) arg3

* output = 'fetch text <' text(iarg) '>  type <' type(iarg) '>'
	eq(type(iarg),3)					:s(fetch_ok)
	eq(type(iarg),4)					:s(fetch_ok)
	lt(itype(iarg,7)					:s(fetch_err)
	gt(itype(iarg,15)					:s(fetch_err)

fetch_err

	error('fetch type not valid, but is ' type(iarg)	:(freturn)

fetch_ok

								:f($('fetch_' type(iarg)))
fetch_3
fetch_4

*  wlbl, clbl

	genop('ldr',reg,'=' text(arg1))
	genop('ldr','[' reg ']')
   								:(return)
fetch_7
fetch_8

*  w,x, map register name

	fetch = text(iarg)					:(return)

fetch_9

*  (x), register indirect

	genop('ldr',reg, '[' text(iarg) ']')
								:(return)

fetch_10

*  (x)+, register indirect, post increment

	ident(text(iarg),'(xs)+) genop('pop','{' reg '})	:s(return)

	genop('ldr',reg, '[' text(iarg), const(cfp_b)])


fetch_11

*	-(x), register indirect, pre decrement

	genop('ldr',reg, '[' text(iarg), const(-cfp_b)])

								:(fetch_done)

fetch_12
fetch_13

*  int(x)
*  dlbl(x)


	text(iarg) break('(') . t1 '(' len(2) . t2
	fetch = tmem '[(cfp_b*' t1 ')+' t2 ']':(return)

fetch_14
fetch_15

*	name(x), where name is in working section

	text(iarg) break('(') . t1 '(' len(2) . t2
	fetch = tmem '[' t1 '+'  t2 ']'	:(return)

fetch_done

								:(return)
fetch_end
-stitl genlab()

	define('genlab()')				:(genlab_end)

*	generate unique label for use in generated code

genlab

	genlab = '_l' lpad(genlabels = genlabels + 1,4,'0'):(return)

genlab_end
-stitl genopl(gopl,gopc,gop1,gop2,gop3)
	define('genopl(gopl,gopc,gop1,gop2,gop3)')	:(genopl_end)

*	generate operation with label

genopl

	cstmts[cstmts.n = cstmts.n + 1] =
.		tstmt(gopl,gopc,gop1,gop2,gop3)		:(return)

genopl_end
-stitl genop(gopc,gop1,gop2,gop3)
	define('genop(gopc,gop1,gop2,gop3)')		:(genop_end)

*	generate operation with no label

genop

	genopl(,gopc,gop1,gop2,gop3)			:(return)

genop_end
-stitl getarg(iarg,imem)
	define('getarg(iarg,imem)l1,l2,t1,t2,tmem')	:(getarg_end)

*	get argument to register and return that register.

getarg

* output = 'getarg text <' text(iarg) '>  type <' type(iarg) '>'
	tmem = (differ(imem) '', 'm_word ')
	l1 = text(iarg)
	l2 = type(iarg)
	eq(l2)						:f($('getarg_c.' l2))

getarg_c.1
	getarg = l1					:(return)

*  int

   getarg = l1						:(return)
getarg_c.2

*  dlbl

   getarg = l1						:(return)

getarg_c.3
getarg_c.4

*  wlbl, clbl

   getarg = tmem '[' l1 ']'				:(return)

getarg_c.5
getarg_c.6

*  elbl, plbl

   getarg = l1						:(return)

getarg_c.7
getarg_c.8

*  w,x, map register name

	getarg = l1					:(return)

getarg_c.9

*  (x), register indirect

	l1 len(1) len(2) . l2
	l2 = l2
	getarg = tmem '[' l2 ']'			:(return)

getarg_c.10

*  (x)+, register indirect, post increment
*  use lea reg,[reg+cfp_b] unless reg is esp, since it takes an extra byte.
*  actually, lea reg,[reg+cfp_b] and add reg,cfp_b are both 2 cycles and 3 bytes
*  for all the other regs, and either could be used.

	l1 = substr(l1,2,2)
	t1 = l1
** FIX *
*	getarg = tmem '[' t1 ']'
*	(ident(l1,xs) genaop(tstmt(,'add',t1,'cfp_b'))) :s(return)
*	genaop(tstmt(,'lea',t1,'[' t1 '+cfp_b]'))	:(return)

getarg_c.11

*	-(x), register indirect, pre decrement

	t1 = substr(l1,3,2)
* output = 'getarg_c.11 t1 <' t1 '>'
	getarg = tmem '[' t1 ']'
	genbop(tstmt(,'lea',t1,'[' t1 '-cfp_b]'))	:(return)

getarg_c.12
getarg_c.13

*  int(x)
*  dlbl(x)


	l1 break('(') . t1 '(' len(2) . t2
	getarg = tmem '[(cfp_b*' t1 ')+' t2 ']':(return)

getarg_c.14
getarg_c.15

*	name(x), where name is in working section

	l1 break('(') . t1 '(' len(2) . t2
	getarg = tmem '[' t1 '+'  t2 ']'	:(return)

getarg_c.16 getarg = l1					:(return)

*  signed integer

getarg_c.17 getarg = l1					:(return)

*  signed real


getarg_c.18

*	=dlbl

	getarg = substr(l1,2)				:(return)

getarg_c.19
*	*dlbl


	getarg = 'cfp_b*' substr(l1,2)			:(return)

getarg_c.20
getarg_c.21
*	=name (data section)


	getarg =  substr(l1,2)				:(return)

getarg_c.22
*	=name (program section)

	getarg =  substr(l1,2)				:(return)

getarg_c.23
getarg_c.24

*	pnam, eqop


	getarg = l1					:(return)

getarg_c.25
getarg_c.26
getarg_c.27

*  ptyp, text, dtext

   getarg = l1						:(return)

getarg_end
-stitl	isreg(iarg)
	define('isreg(iarg)')				:(isreg_end)

*	succeeds if *iarg* is a minimal register name, fails otherwise.
isreg

* output = 'isreg datatype ' datatype(iarg) ' <' datatype(iarg) '>'
	ge(type(iarg),7) le(type(iarg),8)		:f(freturn)s(return)

isreg_end
-stitl initmap(str)
	define('initmap(str),index,val')		:(initmap.end)

*	this routine is called to initialize a table from a string of
*	index/value pairs.

initmap

	initmap = table(size(str))

initmap.1

	str	(break('[') $ index len(1) break(']') $ val len(1)) =
.							:f(return)
	val	= convert( val,'integer' )
	val	= ident(val,lastval) lastval
	lastval = val
	initmap[index] = val				:(initmap.1)

initmap.end
-stitl include(filename)

*	copy contents of *filename*

	define('include(filename)includefile,line')	:(include.end)

include

	input(.includefile,4,filename)			:s(include.next)
	error('cannot open include file ' filename)	:(return)

include.next

	outfile = includefile				:s(include.next)
	endfile(4)					:(return)

include.end
-stitl memmem()t
	define('memmem()t')				:(memmem.end)
memmem

*	memmem is called for those ops for which both operands may be
*	in memory, in which case, we generate code to load second operand
*	to pseudo-register w0, and then modify the second argument
*	to reference this register

	eq(ismem[type(arg1)])				:s(return)
	eq(ismem[type(arg2)])				:s(return)

*	here if memory-memory case, load second argument and then make
*	the second argument *w0*.

	t = getarg(arg2)
	genop('mov',w0,getarg(arg2))
	arg2 = minarg(8,'w0')
							:(return)
memmem.end
-stitl prcent(n)
	define('prcent(n)')				:(prcent_end)

prcent prcent = 'prc_+cfp_b*' ( n - 1)			:(return)

prcent_end
-stitl	report(num,text)

	define('report(num,text)')			:(report_end)

report

	output = rpad('	 ' text ':',30) num			:(return)

report_end
-stitl outstmt(ostmt)label,opcode,op1,op2,op3,comment,line)
	define('outstmt(ostmt)line,label,opcode,op1,op2,op3,comment,t,stmtout')
.			:(outstmt_end)

*	outstmt is used to send a target statement to the output file.

outstmt label = t.label(ostmt)

*	clear label if definition already emitted

	label = ident(label, lastlabel)

outstmt1

*	attach source comment to first generated instruction

	differ(comment)					:s(outstmt2)
	ident(tcomment)					:s(outstmt2)
	comment = tcomment; tcomment =

outstmt2

	opcode = t.opc(ostmt)
	op1 = t.op1(ostmt)
	op2 = t.op2(ostmt)
	op3 = t.op3(ostmt)
	differ(compress)				:s(outstmt3)
	line = rpad( rpad(label,7) ' ' rpad(opcode,4) ' '
.		  (ident(op1), op1
.			(ident(op2), ',' op2
.				(ident(op3), ',' op3))) ,27)
							:(outstmt4)
outstmt3

	line = label tab opcode tab
.		  (ident(op1), op1
.		    (ident(op2), ',' op2
.		      (ident(op3), ',' op3)))

outstmt4

	line = trim(line)
	line = le(size(line),48) rpad(line,48) '; ' comment:s(outstmt5)
	line = le(size(line),56) rpad(line,56) '; ' comment:s(outstmt5)
	line = line '; ' comment

outstmt5
**
**	send text to output file if not null.

*	     line = replace(trim(line),'$','_')

	eq(z_trace)					:s(outstmt6)

*	     here if trace code desired for executable instructions

	chktrace()

outstmt6

* output =  line
	outfile = line
	ntarget = ntarget + 1
	output_lines = output_lines + 1

*	record code labels in table with delimiter removed.
	(ge(sectnow,5) differ(thislabel))		:f(return)
	label ? break(':') . label			:f(return)
	labtab<label> = output_lines			:(return)

outstmt_end
-stitl prsarg(iarg)
	define('prsarg(iarg)l1,l2')			:(prsarg_end)
prsarg

	prsarg = minarg(0)
	iarg break(',') . l1 ',' rem . l2		:f(return)
	prsarg = minarg(convert(l1,'integer'),l2)	:(return)

prsarg_end
-stitl readline()
	define('readline()')				:(readline_end)

*	this routine returns the next statement line in the input lex file
*	to the caller.	it never fails.	 if there is no more input,
*	then a minimal end statement is returned.
*	comments are passed through to the output file directly.

readline

	readline = infile				:f(readline_eof)

	input_lines  = input_lines + 1
	ident( readline )				:f(readline_2)

	outfile = readline
	output_lines = output_lines + 1			:(readline)

readline_2
* output = readline
	lne(substr(readline,1,1 ),'*' )			:s(return)

*	Here if comment.

	z_skip = ident(readline,'*z+') 0		:s(readline)
	z_skip = ident(readline,'*z-') 1		:s(readline)

	outfile = ';' substr(readline,2)
	output_lines = output_lines + 1			:(readline)

readline_eof

   readline = '	       end'				:(return)

readline_end
	define('skip_init(s)on,off')			:(skip_init_end)

*	initialize the skip table used for instruction trace.

skip_init	s break(':') . on ':' rem . off		:f(return)

	skip_on[on] = 1
	skip_off[off] = 1				:(return)

skip_init_end
-sttl	const	return value of symbol defined in definition section
	define('const(iarg)val')			:(const_end)

*	If the argument is a symbol defined in the definition section then
*	return the symbol expressed as an immediate constant.
*	If the argument is an integer, return the integer as an immediate constant.

const

	const = convert(iarg,'integer) '#' convert(iarg,'integer') :s(return)

	ne(type(iarg),2) error('request for undefined symbol: ' text(iarg))	:(return)
	const = '#' text(iarg)				:(return)

symbol_end
-sttl	init - initialize global constants and variables
	define('init()')				:(init_end)

init

*	revision history:

	version = 'v1.12'

*	keyword initialization

	&anchor = 1;	&stlimit = 15000000;	&trim	= 1;  &dump = 1

	&dump = 2

*	useful constants

	letters = 'abcdefghijklmnopqrstuvwxyz'
	ucase	= letters
	lcase	= 'abcdefghijklmnopqrstuvwxyz'
	nos	= '0123456789'
	tab	= char(9)

*	sepchar separates fields in input file

	sepchar = '|'

*	default the parameter string if none present

	fileprefix = "sbl"

*	cfp_b is bytes per word, cfp_c is characters per word these should
*	agree with the values used in translator.  set target-dependent 
*	configuration parameters.

*	cfp_b is bytes per word, cfp_c is characters per word
*	these should agree with values used in translator

	cfp_b = 8
	log_cfp_b = '3'

	cfp_c = 8
	log_cfp_c = '3'

*	used for data declarations
	op_w = 'q'
	op_c = 'b'

*	target register assignments

*	Map registers to their minimal names, since can use gnu as directive .req
*	to map to the actual registers to be used.

*	w0 is temp register

	w0 = 'w0'; w1 = 'w1'; w2 = 'w2'
	wa = 'wa'; wb = 'wb'; wc = 'wc'
	xl = 'xl'; xr = 'wr'; xt = xl
	ia = wc
	cp = 'cp' 

*	pc is the program counter. We use PC when explicitly maniupulating the program branch, typically
*	as part of a branch.

	pc = 'pc'
	PC = pc

*	rcode is used to hold return code value from subroutine call.

	rcode = 'w0'

* symbolic target assignments

*	real_op maps minimal real opcode to machine opcode

	real_op = table(10)
	real_op['adr'] = 'fadd'
	real_op['atn'] = 'fpatan'
	real_op['chp'] = 'frndint'
	real_op['cos'] = 'fcos'
	real_op['dvr'] = 'fdiv'
	real_op['ldr'] = 'fld'
	real_op['mlr'] = 'fmul'
	real_op['ngr'] = 'fchs'
	real_op['sbr'] = 'fsub'
	real_op['sin'] = 'fsin'
	real_op['sqr'] = 'fsqrt'
	real_op['str'] = 'fst'

config_done


*	set z_trace to enable instruction by instruction trace
	z_trace = 1
	z_trace = 0
*	z_limit is maximum number of calls to be generated if non-zero
	z_limit = 000
*	set z_first non-zero to skip first number of instructions that would
*	 generate trace
	z_first = 0
*	will set in_executable when in part of program where executable
*	instructions may occur
	z_exec = 0

*	z_suspend is set to temporarily disable the trace.
	z_suspend = 0
*	set in_skip when should not insert trace code, else assembly errors result.
*	start with skip on, turn off when see first start of code.
	z_skip = 1
*	skip_on and skip_off are labels indicating the start and end,
*	respectively, of sections of the code that should not be traced,
*	usually because they contain a loop instruction that won't
*	compile if too much trace code is inserted.
	skip_on = table(50)
	skip_off = table(50)

*	skip_init('start:ini03')
	skip_init('gbcol:gtarr')
*	skip_init('gtn01:gtnvr')
*	skip_init('bpf05:bpf07')
*	skip_init('scv12:scv19')
*	skip_init('exbl1:exbl2')
*	skip_init('exbl5:expan')
*	skip_init('prn17:prn18')
*	skip_init('inarg11:inarg13')
*	skip_init('oex13:oexp2')
*	skip_init('oex14:oexp6')
*	skip_init('bdfc1:b_efc')
*	skip_init('sar01:sar10')
*	skip_init('srpl5:srpl8')
*	skip_init('pflu1:pflu2')
*	skip_init('prpa4:prpa5')
*	skip_init('prn17:prn18')
*	skip_init('prtvl:prtt1')
*	skip_init('trim4:trim5')
*	skip_init('prnl1:prnl2')
*	skip_init('prtarg1:prtmi')
*	skip_init('srpl5:srpl8')



*	data structures

*	minarg represents an argument to minimal instruction. *type* is the
*	argument's type as operands format of the minimal specification.
*	*text* is the actual text of the argument.

	data('minarg(type,text)')
	data('tstmt(t.label,t.opc,t.op1,t.op2,t.op3,t.comment)')

	sectnow = 0

*	ppm_cases gives count of ppm/err statments that must follow call to
*	a procedure

	ppm_cases = table(50,,0)


	 p.comregs = break(letters) . pre span(letters) . word

*	exttab has entry for external procedures

	exttab = table(50)

*	labtab records labels in the code section, and their line numbers

	labtab = table(500)

*	for each statement, code in generated into three
*	arrays of statements:

*	astmts: statements after opcode (()+, etc.)
*	bstmts: statements before code (-(), etc)
*	cstmts: generated code proper

	astmts = array(20,'')
	bstmts = array(10,'')
	cstmts = array(20,'')

*	genlabels is count of generated labels (cf. genlab)

	genlabels = 0


*	initialize variables

	labcnt = output_lines = input_lines = nstmts = ntarget = nerrors = 0
	lastopc = lastop1 = lastop2 =
	data_lc = 0
	max_exi = 0

*	initial patterns

*	p.csparse parses tokenized line
	p.csparse = sepchar break(sepchar) . inlabel
.	sepchar break(sepchar) . incode
.	sepchar break(sepchar) . iarg1
.	sepchar break(sepchar) . iarg2
.	sepchar break(sepchar) . iarg3
.	sepchar break(sepchar) . incomment
	sepchar rem . slineno

	pifatal = initmap(
.	'aov:1 beq:1 bne:1 bge:1 bgt:1 bhi:1 ble:1 blo:1 blt:1 bne:1 bnz:1 ceq:1 cne:1 mfi:1 nzb:1 zrb:1 ')

*	trace not working for mvc (x64)

	is_executable = initmap(
+	'add:1 adi:1 adr:1 anb:1 aov:1 atn:1 '
+	'bct:1 beq:1 bev:1 bge:1 bgt:1 bhi:1 ble:1 blo:1 blt:1 bne:1 bnz:1 bod:1 '
+	'brn:1 bri:1 bsw:1 btw:1 bze:1 ceq:1 chk:1 chp:1 cmb:1 cmc:1 cmp:1 cne:1 csc:1 '
+	'cos:1 ctb:1 ctw:1 cvd:1 cvm:1 dca:1 dcv:1 eti:1 dvi:1 dvr:1 erb:1 esw:1 etx:1 flc:1 '
+	'ica:1 icp:1 icv:1 ieq:1 ige:1 igt:1 ile:1 ilt:1 ine:1 ino:1 iov:1 itr:1 jmp:1 '
+	'jsr:1 lch:1 lct:1 lcp:1 lcw:1 ldi:1 ldr:1 lei:1 lnf:1 lsh:1 lsx:1 mcb:1 mfi:1 mli:1 mlr:1 '
+	'mnz:1 mov:1 mti:1 mvw:1 mwb:1 ngi:1 eti:1 ngr:1 nzb:1 orb:1 plc:1 prc:1 psc:1 '
+	'req:1 rge:1 rgt:1 rle:1 rlt:1 rmi:1 rne:1 rno:1 rov:1 rsh:1 rsx:1 rti:1 rtn:1 sbi:1 sbr:1 '
+	'sch:1 scp:1 sin:1 sqr:1 ssl:1 sss:1 sti:1 str:1 sub:1 tan:1 trc:1 wtb:1 xob:1 zer:1 '
+	'zgb:1 zrb')

*	various constants

	comment.delim = ';'

*	optim.tab flags opcodes capable of participating in or optimization in outstmt routine.

	optim.tab = table(10)

	optim.tab<"and"> = optim.tab<"add"> = optim.tab<"sub"> =
.	optim.tab<"neg"> = optim.tab<"or">  = optim.tab<"xor"> =
.	optim.tab<"shr"> = optim.tab<"shl"> = optim.tab<"inc"> = 
.	optim.tab<"dec"> = 1


*	ismem is a map from operand type that is nonzero if the operand type
*	is a memory reference.

	ismem = array(30,0)

	ismem<3> = ismem<4> = ismem<5> = ismem<9> = ismem<10> = 
.	ismem<11> = ismem<12> = ismem<13> = ismem<14>  = ismem<15> = 1

*	other definitions that are dependent upon things defined in the
*	machine definition file, and cannot be built until after the definition
*	file has been read in.

*	p.outstmt examines output lines for certain types of comment contructions

	fillc	  = (ident(compress) " ",tab)
	p.outstmt = (break(fillc) . label span(fillc)) . leader
+			comment.delim rem . comment
	p.alltabs = span(tab) rpos(0)


	filenami = 'sbl.lex'
	input(.infile,1,filenami)			:s(inputok)

inputok

	report(filenami, 'input lex file')

*	associate output files.

	filenamo = 'sbl.asm'
	output(.outfile,2,filenamo)			:s(outputok)
	output = '  cannot open asm file: ' filenamo	:(end)

outputok

	output = report(filenamo,'output asm file')

*	open file for compilation of minimal err and erb messages

	output(.errfile,3, fileprefix ".err")		:s(err_ok)
	output = "  cannot open error message file: " fileprefix ".err":(end)
err_ok

*	will have havehdr non-null if more remains to copy out at end.

							:(nopub)
*	read in pub file if it exists.	this contains a list of symbols to
*	be declared public when encountered.

	pubtab = table(2)
	input(.pubfile,5, fileprefix ".pub")		:f(nopub)
	pubtab = table(101)

pubcopy

	line = pubfile					:f(pubend)
	pubtab[line] = 1				:(pubcopy)

pubend

	 endfile(5)

nopub


*	get file name


*  get definition file name following token file name, and flags.

*	fileprefix ? break(';:') . fileprefix len(1) 
*.	(break(';:') | rem) . target
*.	((len(1) rem . flags) | '')

*	$replace(target,lcase,ucase) = 1

*	parse and display flags, setting each one's name to non-null value (1).

							:(flgs.skip)
flgs

   flags ? ((len(1) break(';				:')) . flag len(1)) |
.	 ((len(1) rem) . flag) =			:f(flgs2)
	flag = replace(flag,lcase,ucase)
	output = "  flag				: " flag
	$flag = 1					:(flgs)

flgs.skip

flgs2

							:(return)
init_end
-stitl main program

*	here follows the driver code for the "main" program.

	init()

*	loop until program exits via g_end

*	opnext is invoked to initiate processing of the next line from
*	readline_
*	after doing this, opnext branches to the generator routine indicated
*	for this opcode if there is one.

*	the generators all have entry points beginning with "g_",
*	and can be considered a logical extension of the opnext routine.
*	the generators have the choice of branching back to dsgen to cause
*	the thisstmt plex to be sent to outstmt, or or branching to opnext,
*	in which case the generator must output all needed code itself.

*	the generators are listed in a separate section below.

*	&trace = 2000
*	&ftrace = 1000
*	&profile = 1

	include('int.h')
	include('int.dcl')

*	Main loop - read next line and generate necessary code for it.

	&dump = 2
opnext

	 thisline = readline()
	 crack(thisline)				:f(opnext)
	 op_ = incode '_'

*	append ':' after label if in code or data.

*	output label of executable instruction immediately if there is one,
*	as it simplifies later processing, especially for tracing_

	ident(inlabel)					:s(opnext.1)
	thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)

*	keep the label as is is not in executable code

	lt(sectnow,5)					:s(opnext.1)

*	here if in code, so output label now
*	defer label processing for ent to allow emission of alignment ops for x86.

	ident(incode,'ent')				:s(opnext.1)
	outfile = thislabel
	outlines = outlines + 1

*	set lastlabel so can check to avoid emitting duplicate label definitions

	lastlabel = thislabel

*	clear out label info once generated

	label = thislabel =

opnext.1

	thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)
	arg1 = prsarg(iarg1)
	arg2 = prsarg(iarg2)
	arg3 = prsarg(iarg3)
	tcomment = comregs(incomment) '} ' incode ' ' text(arg1) ' '
.		text(arg2) ' ' text(arg3)
	argerrs = 0
* output = 'bad incode ' incode
							:($('g_' incode))
*	here if bad opcode

op_error

	error('bad op-code')				:(opnext)

*	generate tokens.

ds.typerr

	error('operand type zero')			:(opnext)
-stitl generators

*	### 1-	Basic Instruction Set

*	*   1.1	 MOV   _opn,opv_  move one word value

*	MOV causes the value of operand _opv_ to be set as the new contents
*	of operand location _opn_. In the case where _opn_ is not an index
*	register, any value which can normally occupy a memory word
*	(including a part of a multiword real or integer value) can be
*	transferred using MOV. If the target location _opn_ is an index register,
*	then _opv_ must specify an appropriate one word value or operand
*	containing such an appropriate value.

g_mov

	ident(text(arg1),'-(xs)')			:s(g_mov_push)
	fetch(w1,arg1)
	store(w1,arg2)					:(opdone)

g_mov_push

	fetch(w2,arg)
	genop('push', '{' w2 '}')			:(opdone)


*	* 1.2  BRN  _plbl_    unconditional branch

*	BRN causes control to be passed to the indicated label in
*	the program section.

g_brn

	genop('adr',PC,text(arg1))			:(opdone)

*	* 1.3  BSW  _x,val,plbl_    branch on switch value

*	BSW IFF,ESW provide a capability for a switched branch similar to a
*	fortran computed goto.  The _val_ on the BSW instruction is the
*	maximum number of branches. the value in x ranges from zero up to
*	but not including this maximum. each IFF provides a branch.

*	_val_ must be less than that given on the bsw and control goes to
*	_plbl_ if the value in x matches.  If the value in x does not correspond
*	to any of the IFF entries, then control passes to the _plbl_ on the BSW.

*	The  _plbl_ operand may be omitted if there are no values missing
*	from the list.

*	IFF and ESW may only be used in this context.  Execution of BSW
*	may destroy the contents of _x_.

*	The IFF entries may be in any order and since a translator may thus need
*	to store and sort them, the comment field is restricted in length (sec 11)

g_bsw

	fetch(w1,arg1)
	genop('mov',w2,const(arg2))
	t2 = genlab()
	z_suspend = 1
	ident(text(arg3))				:s(g_bsw1)

*	Here if _plbl_, so generate branch to it if out or range
	genop('cmp',w1,const(arg2))
	genop('jge',text(arg3))

*  here after default case.

g_bsw1

*	Use TBH instruction:
*		tbh PC, w1, lsl #1
*	where
*		Rn is the base register for table. Use PC if table follows this instruction.
*
*		r1 is integer index. The offset into the table is this value, shifted to
*		get halfword offset.
*		
*		The first case follows this instruction.

	genop('tbh','[' PC ',' r1 ','  const(1) ']')

*	tbh_label is value of PC for first entry in table

	tbh_label = genlab()
	z_suspend = 0
							:(opdone)

*	* 1.4  IFF  _val,plbl_	      provide branch for switch

*	```
*		    IFF	 val,_plbl_	...
*		    ...
*		    ...
*	```

*	Note that the lowest IFF entry value for _val_ is always zero.
*	The IFF statements have been sorted into the proper order by the lexical scanner.

g_iff

	genop('.int', '((' text(arg2) ' - ' tbh_label ')/2)')	:(opdone)


*	* 1.5  ESW	end of branch switch table

g_esw
							:(opdone)

*	*   1.6	 ENT  _val_ define program entry point

*	The symbol appearing in the label field is defined to be a program entry
*	point which can subsequently be used in conjunction with the BRI
*	instruction, which provides the only means of entering the code. 

g_ent

*	entry points are stored in byte before program entry label last arg is
*	optional, in which case no initial 'db' need be issued. we force
*	odd alignment so can distinguish entry point addresses from block
*	addresses (which are always even).

*	note that this address of odd/even is less restrictive than the minimal
*	definition, which defines an even address as being a multiple of
*	cfp_b * 4, and an odd address as one that is not a multiple of
*	cfp_b (ends in 1, 2, or 3).  the definition here is a simple odd/even,
*	least significant bit definition. that is, for us, 1 and 3 are odd,
*	2 and 4 are even.

*	Note that it may be possible to use the byte before program as ARM V7
*	archiecture supports LDRD and STRB on bytes. Need to investigate,but
*	for now am disabling these instructions.

*	As a consequence operations BEV and BOD need not be implemented, as
*	entry point is implemented as full word.


	t1 = text(arg1)
	genop('.long',text(arg1))

							:(opdone)


	outlines = outlines + 2
	genopl(thislabel)

*	note that want to attach label to last instruction
*	     t1 = cstmts[cstmts.n]
*	     t.label(t1) = tlabel
*	     cstmts[cstmts.n] = t1
*	here to see if want label made public

	thislabel ? rtab(1) . thislabel '		:'
*	(differ(pubtab[thislabel]), differ(debug)) genop('.globl',thislabel)
	thislabel =					:(opdone)

*	*   1.7	 BRI   _opn_	  branch indirect

*	_opn_ contains the address of a program entry point (see ent).
*	control is passed to the executable code starting at the entry point
*	address.  _opn_ is left unchanged.

g_bri

	fetch(w1,arg1)
	genop('mov',PC,r1)				:(opdone)

*	*   1.8	 LEI  _x_	  load entry point identification

*	_x_ contains the address of an entry point for which an identifying value was
*	given on the the ENT line. LEI replaces the contents of _x_ by this value.

g_lei

	fetch(w1,arg1)
	genop('ldr','[' w1 ', ' const(4) ']')		:(opdone)

*	*   1.9	 JSR  _pnam_	  call procedure _pnam_

g_jsr

	jsr_proc = text(arg1)

*	get count of following ppm statements

	jsr_count = ppm_cases[jsr_proc]
	eq(jsr_count)					:s(opdone)
	z_suspend = 1
	jsr_calls = jsr_calls +	 1
	jsr_label = 'call_' jsr_calls
	jsr_label_norm = jsr_label
	genop('subs',rcode,rcode,const(1))
	genop('stmfc,sp '!'_)
	adr(w1,jsr_label)
	genop('movs',PC,r1)
	z_suspend = 0

*	     generate branch around for ppms that will follow
*	     take the branch if normal return (r1==0)
							:(opdone)

*	*   1.10 PPM  _plbl_	  provide exit parameter

*	```
*		    PPM	 _plbl_		...
*		    ...
*		    PPM	 _plbl_		...
*	```

*	JSR causes control to be passed to the named procedure. _pnam_ is the label on a PRC
*	statement elsewhere in the program section (see prc) *	or has been defined using an *exp* instruction.

*	The PPM exit parameters following the call give names of program locations (_plbl_-s) to
*	which alternative EXI returns of the called procedure may pass control.

*	They may optionally be replaced by error returns (see err). the number of exit parameters
*	following a JSR must equal the int in the procedure definition.

*	The operand of PPM may be omitted if the corresponding EXI return is certain not to be taken.

g_ppm							

*	PPM and ERR are handled the same way.

							:(g_err)

*	*   1.11 PRC  _ptyp,int_  define start of procedure

*	The symbol appearing in the label field is defined to be the name of a procedure for use with JSR a
*	procedure is a contiguous section of instructions to which control may be passed with a JSR instruction.

*	This is the only way in which the instructions in a procedure may be executed.

*	It is not permitted to fall into a procedure.  Procedures should be named in section 0 INP statements.

*	_int_ is the number of exit parameters (PPM-s) to be used in JSR calls.


g_prc

*	generate public declaration
*	     t1 = thislabel
*	     t1 ? rtab(1) . t1 ':'
*	     genop()
*	     genop('.globl',t1)

	prc.args = getarg(arg2)
	ppm_cases[thislabel] = text(arg2)
	thislabel =
	max_exi = gt(prc.args,max_exi) prc.args
	prc.type = text(arg1)			:($('g_prc.' prc.type))

g_prc.e
g_prc.r							:(opdone)

g_prc.n

	error('TODO prc return')			:(opdone)

*	store return address in reserved location

	genop('ldmfd', sp '!')
	prc.count = prc.count + 1
	genop('pop', 'm_word [' prcent(prc.count) ']')	:(opdone)

*	*   1.12 EXI  _int_	  exit from procedure


*	The PPM and ERR parameters following a JSR are numbered starting from 1.

*	EXI int causes control to be returned to the int-th such param. EXI 1 gives control to the
*	_plbl_ of the first PPM after the JSR if _int_ is omitted, control is passed back past the
*	last exit parameter (or past the JSR if there are none).

*	For _r and_ _e_ type procedures, the stack pointer XS must be set to its appropriate entry
*	value before executing an EXI instruction.

*	In this case, EXI removes return points from the stack if any are stored there so that the
*	stack pointer is restored to its calling value.

g_exi

	error('TODO exi')				:(opdone)
	t2 = prc.type; t3 = text(arg1)

*	if type r or e, and no exit parameters, just return

	differ(t2,'n') eq(prc.args)	genop('ldmfd',sp '!') :s(opdone)
	t3 = ident(t3) '0'
	genop('adr','rcode
	genop('mov',w0,const(+t3))
	ident(t2,'n')					:s(g_exi.1)
	genop('ldmfd', sp '!')				:(opdone)

g_exi.1

	error('error g_exi.1')				:(opdone)
	genop('mov',w0, 'm_word ['  prcent(prc.count) ']' )
	genop('jmp',w0)
							:(opdone)

*	*   1.13 ENP  define end of procedure body

*	ENP delimits a procedure body and may not actually be executed, hence it must have no label.

g_enp	genop()						:(opdone)

*	*   1.14 ERR  _int,text_  provide error return

*	ERR may replace an exit parameter (PPM) in any procedure call. The int argument is a unique
*	error code in 0 to 899.

*	The text supplied as the other operand is arbitrary text in the FORTRAN character set and may
*	be used in constructing a file of error messages to be used by the error handling code.

*	In the event that an EXI attempts to return control via an exit parameter to an ERR control
*	is instead passed to the first instruction in the error section (which follows the program
*	section) with the error code in WA.

g_err

*	Here with return code in rcode. it is zero for normal return and positive for error return.
*	Decrement the value. if it is negative then this is normal return. otherwise, proceed, decrementing
*	_rcode_ until it goes negative,and then take the appropriate branch.

	t1 = text(arg1)

*	branch to next case if rcode code still not negative.

	ident(incode,'ppm')				:s(g_ppm.loop)
	count.err =  count.err + 1
	errfile =   text(arg1) ' ' text(arg2)
	max.err = gt(t1,max.err) t1
							:(g_ppm.loop)

g_ppm.loop.next

	genopl(lab_next ':')
	jsr_count = jsr_count - 1
	z_suspend = eq(jsr_count) 0
	eq(jsr_count) genopl(jsr_label_norm ':')	:(opdone)

g_ppm.loop

	lab_next = genlab()
	genop('subs',rcode,const(1))
	genop('mov',PC,adr(lab_next))
	ident(incode,'ppm')				:s(g_ppm.loop.ppm)

*	here if error exit via exi. set rcode to exit code and jump to handler with error code in rcode

g_ppm.loop.err

	genop('mov',rcode, const('+' t1))
	genop('adr', w1,'err_')
	genop('mov',PC,r1)
							:(g_ppm.loop.next)
g_ppm.loop.ppm

*	check each ppm case and take branch if appropriate

	ident(text(arg1))				:s(g_ppm.2)
	count.ppm = count.ppm + 1
	genop('adr',w1,text(arg1))
	genop('mov',PC',r1)
							:(g_ppm.loop.next)

g_ppm.2

*	a ppm with no arguments, which should never be executed, is
*	translated to err 299,internal logic error: unexpected ppm branch

	t1 = 299
	errfile =  t1 ' internal logic error		: unexpected ppm branch'
							:(g_ppm.loop.err)

*	*   1.15 ERB  _int,text_  error branch

*	This instruction resembles ERR except that it may occur at any point
*	where a branch is permitted. It effects a transfer of control to the
*	error section with the error code in WA.

g_erb
	errfile =  text(arg1) ' ' text(arg2)

*	set rcode to error code and branch to error handler

	genop('mov',rcode,const(text(arg1)))
	genop('mov',w1,adr('err_'))
	genop('mov',PC',r1)
							:(opdone)

g_ssl
g_sss
g_rtn

	genop()						:(opdone)

*	real operations

*	lch requires separate cases for each first operand possibility.

*	*   7.8	 LSX  _w,(x)_

*	Left shift _w_ by the  number of bits in _x_


*	The above shifts are logical shifts in which bits shifted out are lost
*	and zero bits supplied as required. The shift count is in the
*	range 0-CFP$N .

g_lsx

	error('lsx not supported')

g_zzz


	genop('zzz',text(arg1))				:(opdone)


*	*   8.7	 CTW  _w,val_

*	This instruction computes the sum (number of words required to store 
*	w characters) + (val). the sum is stored in _w_.

*	For example, CFP$C is 5, and WA contains 32, then CTW WA,2
*	gives a result of 9 in WA.


g_ctw

*	assume cfp_c chars per word

	fetch(w1,arg1)
	error('TODO ctw')				:(opdone)
	t1 = getarg(arg1)
	eq(cfp_b,cfp_c)					:s(g_ctw.1)

*	here if one word per character, so just add character count

	genop('add',w1,text(arg2))
							:(opdone)
g_ctw.1

	fetch(w1,arg1)
	genop('add',w1,const('(cfp_c - 1) + cfp_c * text(arg2)))
	genop('lsr',w1,w1,const('log_cfp_c'))
							:(opdone)
g_sec

	genop('')
	sectnow = sectnow + 1				:($("g_sec." sectnow))

*  procedure declaration section

g_sec.1

	genop('segment .text')
	genop('global','sec01')
	genopl('sec01' ':')				:(opdone)

*	definitions section

g_sec.2

	genop('global','sec02')
	genopl('sec02' ':')				:(opdone)

*  constants section

g_sec.3

	genop('global','sec03')
	genopl('sec03' ':')				:(opdone)

*  working variables section

g_sec.4

	genop('global','esec03')
	genopl('esec03' '				:')
	genop('global','sec04')
	genopl('sec04' ':')				:(opdone)

*	here at start of program section.  If any n type procedures, put out entry-word block
*	declaration at end of working storage

g_sec.5

	error('TODO g_sec.5')				:(opdone)

*	emit code to indicate in code section.

	genop('global','esec04')
	genopl('esec04' '				:')

*	      (gt(prc.count1) genopl('prc$' ':','times', prc.count1 ' dd 0'))

	genopl('prc_')
	genop('.rept' tab prc_count1)
	genop('.word' tab '0')
	genop('endr')

	genop('.global','lowspmin')
	genopl('lowspmin,'dd', '.word 0')
	genop('.global','end_min_data')
	genopl('end_min_data' ':')
	genop('.global','sec05')
	genopl('sec05' ':')				:(opdone)

*	stack overflow section.	 output exi__n tail code

g_sec.6

	genop('global','sec06')
	genopl('sec06')
							:(opdone)

*	error section.	produce code to receive erb's

g_sec.7

	error('TODO g_sec..7')				:(opdone)
	genop('global','sec07')
	genopl('sec07' '				:')
	flush()
*	error section.	produce code to receive erb's

*	allow for some extra cases in case of max.err bad estimate

	n1 = max.err + 8
	output = '  max.err ' max.err
	genopl('err_ :','xchg',wa,'m_word [' rcode ']') :(opdone)



opdone

	flush()						:(opnext)
opdone.end
g_end

	&dump = 2
	&dump = 0
	ident(havehdr)					:s(g_end.2)

*	here to copy remaining part from hdr file

g_end.1

	line = hdrfile					:f(g_end.2)
	ntarget = ntarget + 1
	output_lines = output_lines + 1
	outfile = line					:(g_end.1)

g_end.2

*	here at end of code generation.

	endfile(1)
	endfile(2)
	endfile(3)
	report(input_lines,	'lines read')
	report(nstmts,		'statements processed')
	report(ntarget,		'target code lines produced')
	report(&stcount,	'spitbol statements executed')
	report(max.err,		'maximum err/erb number')
	report(prc.count1,	'prc count')
	output	= '  ' gt(prc.count,prc.count1)
.	  '  differing counts for n-procedures:'
.	  ' inp ' prc.count1 ' prc ' prc.count
	differ(nerrors) report(nerrors,'errors detected')

	errfile = '* ' max.err ' maximum err/erb number'
	errfile	= '* ' prc.count ' prc count'
.		differ(lasterror) '  the last error was in line ' lasterror

	&code	= ne(nerrors) 2001
	report(collect(), 'free words')
							:(end)

*	*   1.16 ICV   _opn_  increment value by one

*	ICV increments the value of the operand by unity.

g_icv

	fetch(w1,arg1)
	genop('add',
	genop('inc',w1,const(1))			:(opdone)

*	*   1.17 DCV   _opn_	  decrement value by one

*	DCV decrements the value of the operand by unity.

g_dcv

	error('TODO dcv')				:(opdone)
	fetch(w1,arg1)
	genop('dec',w1,const(1))			:(opdone)

*	*   1.18 ZER   _opn_

*	ZER is equivalent to MOV =zeroe,_opn_

g_zer

	fetch(w1,arg1)
	genop('xor,w1,r1)
	store(w1,arg1)
							:(opdone)

*	*   1.19 MNZ   _opn_ move

*	Any non-zero collectable value may used, for which the opcodes _bnz_/_bze_ will branch/fail
*	to branch.


g_mnz

	fetch(argreg,arg1)
	genop('xor',argreg,argreg)
	store(argreg,xs)
							:(opdone)

*	*   1.20 SSL   _opw_	  subroutine stack load

*	*   1.21 SSS   _opw_	  subroutine stack store

*	This pair of operations is provided to make possible the use of a
*	local stack to hold subroutine (subroutine) return links for n-type
*	procedures.

*	SSS stores the subroutine stack pointer in _opw_ and SSL loads the
*	subroutine stack pointer from _opw_.

*	By using SSS in the main program or on entry to a procedure which
*	should regain control on occurrence of an ERR or ERB and by use of
*	SSL in the error processing sections the subroutine stack pointer can be
*	restored giving a link stack cleaned up ready for resumed execution.

*	The form of the link stack pointer is undefined in MINIMAL (it is likely
*	to be a private register known to the translator) and the only
*	requirement is that it should fit into a single full word.

*	SSL and SSS are no-ops if no private link stack is not used.

*	A private link stack is not used in the ARM implementation.

*	*   1.22 RTN define start of routine


*	However it is entered by any type of conditional or unconditional
*	branch (not by JSR).

*	On termination it passes control by a branch (often BRI through a code word) or even permits
*	control to drop through to another routine.

*	No return link exists and the end of a routine is not marked by an explicit opcode (compare ENP).

*	All routines must be named in section 0 INR statements.	 

*	#### 2-	 Operations on One Word Integer Values (addresses)


*	*   2.1	 ADD   _opn,opv_

*	Adds  _opv_ to the value in  _opn_ and stores the result in  _opn_.  Undefined if the result
*	exceeds CFP$L .

g_add

	fetch(w1,arg1)
	fetch(w2,arg3)
	genop('add',w1,w1,w2)
	store(w1, 1)					:(opdone)

*	*   2.2	 SUB   _opn,opv_

*	Subtracts _opv_ from _opn_, and stores the result in _opn_. Undefined if the result is negative.

g_sub


	fetch(w1,arg1)
	fetch(w2,arg3)
	genop('sub',w1,w1,w2)
	store(w1, 1)					:(opdone)


*	*   2.3	 ICA   _opn_


*	Increment address in  _opn_ *	Equivalent to ADD  _opn_,*unity

g_ica	

	fetch(w1,arg1)
	genop('add',w1,const('cfp_b'))
	store(w1,1)					:(opdone)

*	*   2.4	 DCA   _opn_

*	Decrement address in _opn_ equivalent to SUB _opn_,*unity

g_dca

	fetch(w1,arg1)
	genop('sub',w1,const('cfp_b'))
	store(w1,1)					:(opdone)


*	The following instructions compare two address values as unsigned integer values.
*	The BLO and BHI instructions are used in cases where the equal condition either does not occur
*	or can result either in a branch or no branch.

*	This avoids inefficient translations in some implementations.

*	*   2.5	 BEQ   _opn,opv,plbl_

*	Branch to _plbl_  _opn_ eq  _opv_

	cond = 'eq'					:(g_bop)

*	*   2.6	 BNE   _opn,opv,plbl_

*	Branch to _plbl_  _opn_ ne  _opv_

	cond = 'ne'					:(g_bop)

*	*   2.7	 BGT   _opn,opv,plbl_

*	Branch to _plbl_  _opn_ gt  _opv_

	g_bop = 'gt'					:(g_bop)

*	*   2.8	 BGE   _opn,opv,plbl_

	g_bop = 'ge'					:(g_bop)

*	Branch to _plbl_  _opn_ ge  _opv_

*	*   2.9	 BLT   _opn,opv,plbl_

	g_bop = 'lt'					:(g_bop)

*	Branch to _plbl_  _opn_ lt  _opv_

*	*   2.10 BLE   _opn,opv,plbl_

	g_bop = 'le'					:(g_bop)

*	Branch to _plbl_  _opn_ le  _opv_

*	*   2.11 BLO   _opn,opv,plbl_

*	Equivalent to BLT or BLE

	g_bop = 'lo'					:(g_bop)

*	*   2.12 BHI   _opn,opv,plbl_

*	Equivalent to BGT or BGE

	g_bop = 'hi'					:(g_bop)

g_bop

	fetch(w1,arg1)
	fetch(w2,arg3)
	genop('cmp',w1,w2)
	fetch(w0,3)
	genop('cmp',w1,w2)
	genop('mov' g_bop,PC,w0)
							:(opdone)

*	*   2.13 BNZ   _opn,plbl_

*	Equivalent to BNE  _opn_,=zeroe,_plbl_

*	*   2.14 BZE   _opn,plbl_

*	Equivalent to BEQ  _opn_,=zeroe,_plbl_

g_bnz

	fetch(w1,arg1)
	genop('adr',text(arg3))
	genop('ors',w1,w1)
	fetch(w3,1)
	genop('movne',PC, w3)				:(opdone)

g_bze	

	fetch(w1,arg1)
	genop('adr',text(arg3))
	genop('ors',w1,w1)
	fetch(w3,1)
	genop('moveq',PC, w3)				:(opdone)

*	*   2.15 LCT  _w,opv_

*	Load counter for BCT

*	LCT loads a counter value for use with the BCT instruction. The value in _opv_ is the number
*	of loop operations to be executed.

*	The value in _w_ after this operation is an undefined one word integer quantity.

g_lct

	error('TODO lct')				:(opdone)

*	if operands differ must emit code

	differ(text(arg1),text(arg2))			:s(g_lct.1)

*	here if operands same. emit no code if no label, else emit null

	ident(thislabel)				:s(opnext)
	genop()						:(opdone)

g_lct.1

	fetch(w1,arg1)
	fetch(w2,arg3)
	genop('mov',w1,w2)				:(opdone)

*	*   2.16 BCT  _w,plbl_

*	Branch and count

*	BCT uses the counter value in w to branch the required number of times and then finally to fall
*	through to the next instruction.

*	BCT can only be used following an appropriate LCT instruction.

*	The value in _w_ after execution of BCT is undefined.

g_bct

	error('TODO bct')				:(opdone)
*	can issue loop if target register is cx.

	w1 = getarg(arg1)
	w2 = getarg(arg2)
	w3 = adr(arg2)
	genop('subs',w1,'const(1))
	genop('movne',PC,w3)				:(opdone)

*	*   2.17 AOV   _opn,opv,plbl_

*	ADD with carry test

*	Adds  _opv_ to the value in  _opn_ and stores result in _opn_.

*	Branches to _plbl_ result exceeds CFP$L with result in	_opn_*
	undefined. 

g_aov

	error('TODO aov')				:(opdone)
	genop('add',getarg(arg2),getarg(arg1))
	genop('jc',getarg(arg3))
							:(opdone)
*	*   2.18 BEV   _opn,plbl_

*	Branch even

*	*   2.19 BOD   _opn,plbl_

*	Branch odd

*	These operations are used only .cepp or .crpp is defined.

*	On some implementations, a more efficient implementation is possible by noting that 
*	address of blocks must always be a multiple of CFP$B. We call such addresses even.

*	Thus return address on the stack (.crpp) and entry point addresses (.cepp) can be distinguished 
*	from block addresses they are forced to be odd (not a *	multiple of CFP$B ). 
*	EV and BOD branch according as operand is even or odd, respectively.

*	The instructions are not currently required, and so are not implemented. 
*	See comment for ENT instruction above

g_bev

	error('BEV not supported)			:(opnext)

g_bod

	error('BOD not supported)			:(opnext)

*	 #### 3- Operations on the Code Pointer Register

*	(CP )

*	The code pointer register provides a psuedo instruction counter for use in an interpretor. It may 
*	be implemented as a real register or as a memory location, but in either case it is separate 
*	from any other register.

*	*   3.1	 LCP   _reg_

*	Load code pointer register

*	This instruction causes the code pointer register to be set from the
*	value in _reg_ which is unchanged

g_lcp	
	error('TODO lcp')				:(opdone)
	genop(op_,getarg(arg1))				:(opdone)

*	*   3.2	 SCP   _reg_

*	Store code pointer register this instruction loads the current value in the code pointer 
*	register into reg_ (CP ) is unchanged.

g_scp	     
	error('TODO lcp')				:(opdone)
	genop(op_,getarg(arg1))			:(opdone)

*	*   3.3	 LCW  _reg_

*	Load next code word

*	This instruction causes the word pointed to by CP to be loaded into the indicated reg_
*	 The value in CP is then incremented by one word.

*	Execution of LCW may destroy XL .

g_lcw  
	error('TODO lcp')				:(opdone)
	genop(op_,getarg(arg1))				:(opdone)

*	*   3.4	 ICP

*	Increment CP  by one word

*	On machines with more than three index registers, CP can be treated simply as an index register.

*	Current implementation keeps *CP* in memory.

g_icp	
	error('TODO lcp')				:(opdone)
	genop(op_,getarg(arg1))				:(opdone)

*	#### 4-	 Operations on Signed Integer Values

*	*   4.1	 LDI   _ops_

*	Load integer accumulator from  _ops_

g_ldi

	fetch(w1,arg1)					:(opdone)

*	*   4.2	 ADI   _ops_

*	ADD  _ops_ to integer accumulator

g_adi

	fetch(w1,arg1)
	genop('adds',wc,w1)				:(opdone)

*	*   4.3	 MLI   _ops_ 

*	Multiply integer accumulator by	 _ops_

g_mli

	fetch(w1,arg1)
	genop('muls',wc,wc,w1)				:(opdone)

*	*   4.4	 SBI   _ops_

*	Subtract  _ops_ from int accumulator

g_sbi

	fetch(w1,arg1)
	genop('subs',wc,w1)				:(opdone)

*	*   4.5	 DVI   _ops_

*	Divide integer accumulator by  _ops_


g_dvi

*	In ARM V7, signed and unsigned division are avilable in the THUMB instruction set, with
*	the instructions UDIV and SDIV.

	fetch(w1,arg1)

*	need to check if divisor is zero, so can catch via software.

	genop('sdivs',wc,r1)
	error ('idiv todo')				:(opdone)

*	*   4.6	 RMI   _ops_

*	Set integer accumulator to `mod(intacc,_ops_)`

g_rmi

	fetch(w1,arg1)
	error ('rmi todo')				:(opdone)

*	*   4.7	 STI   _ops_

*	Store integer accumulator at  _ops_
	
	store(ia,fetch(ia,1))				:(opdone)

*	*   4.8	 NGI

*	Negate the value in the integer accumulator (change its sign)

g_ngi

	fetch(ia,1)
	
*	Use NEG pseudo-instruction

	genop('neg',ia,ia)				:(opdone)

*	*   4.9	 INO  _plbl_

*	Jump to _plbl_ if no integer overflow

g_ino

	genop('adrvc',w3,text(arg1))
	genop('movvc',PC,w3)				:(opdone)

*	*   4.10 IOV  _plbl_

*	Jump to _plbl_ if integer overflow

*	These instructions can only occur immediately following an instruction which can cause 
*	integer overflow (ADI, SBI MLI DVI RMI ngi) and test the result of the preceding instruction.

*	IOV and INO may not have labels.

g_iov

	genop('adrvs',w3,text(arg1))
	genop('movvs',PC,w3)				:(opdone)

*	*   4.11 IEQ  _plbl_

g_ieq	opcode = 'beq'					:(g_ia)

*	Jump to _plbl_ if (IA) eq 0

*	*   4.12 IGE  _plbl_

g_ige	opcode = 'bge'					:(g_ia)

*	Jump to _plbl_ if (IA) ge 0

*	*   4.13 IGT  _plbl_

g_igt	opcode = 'bgt'					:(g_ia)

*	Jump to _plbl_ if (IA) gt 0

*	*   4.14 ILE  _plbl_

*	Jump to _plbl_ if (IA) le 0

g_ile	opcode = 'ble'					:(g_ia)

*	*   4.15 ILT  _plbl_

g_ilt	opcode = 'blt'					:(g_ia)

*	Jump to _plbl_ if (IA) lt 0

*	*   4.16 INE  _plbl_

*	Jump to _plbl_ if (IA) ne 0

g_ine	opcode = 'bne'					:(g_ia)

*	The above conditional jump instructions do not change the contents of the accumulator.

g_ia

	genop('cmp',wc,'#0')
	genop(opcode,getarg(1))				:(opdone)

g_sti

	genop('mov',getarg(arg1),ia)			:(opdone)

g_ngi
	genop('neg',ia)					:(opdone)


*	 #### 5- Operations on Real Values 

*	Real arithmetic not supported for bootstrap version

*	*   5.1	 LDR   _ops_

*	Load real accumulator from  _ops_

*	*   5.2	 STR   _ops_

*	Store real accumulator at  _ops_


*	*   5.3  ADR	_ops_

*	ADD  _ops_ to real accumulator

*	*   5.4	 SBR   _ops_

*	Subtract  _ops_ from real accumulator


*	*   5.5	 MLR   _ops_

*	Multiply real accumulator by  _ops_

*	*   5.6	 DVR   _ops_

*	Divide real accumulator by  _ops_

*	If the result of any of the above operations causes underflow, the result yielded is 0.0.

*	The result of any of the above operations is undefined or out of range, real overflow is set,
*	 the contents of (RA) are undefined and the following instruction must be either ROV or RNO.

*	Particular care may be needed on target machines having distinct overflow and divide by zero conditions.

*g_ldr
*g_str
*g_adr
*g_sbr
*g_mlr
*g_dvr

	t1 = getarg(arg1,'m_word')
	genop('lea',w0,t1)
	genop('call',op_)
							:(opdone)
*	*   5.7	 ROV  _plbl_

*	Jump to _plbl_ real overflow

*	*   5.8	 RNO  _plbl_

*	Jump to _plbl_ no real overflow

*	These instructions can only occur immediately following an instruction which can cause real 
*	overflow (ADR,SBR MLR DVR.

*g_rov
*g_rno
	genop(op_,getarg(arg1))				:(opdone)

*	*   5.9 NGR

*	Negate real accumulator (change sign)

*g_ngr 
	genop('call',op_)
							:(opdone)
*	*   5.10 REQ  _plbl_

*	Jump to _plbl_ if (RA) eq 0.0

*	*   5.11 RGE  _plbl_

*	Jump to _plbl_ if (RA) ge 0.0

*	*   5.12 RGT  _plbl_

*	Jump to _plbl_ if (RA) gt 0.0


*	*   5.13 RLE  _plbl_

*	Jump to _plbl_ if (RA) le 0.0

*	*   5.14 RLT  _plbl_

*	Jump to _plbl_ if (RA ) lt 0.0

*	*   5.15 RNE  _plbl_

*	Jump to _plbl_ if (RA) ne 0.0

*	The above conditional instructions do not affect the value stored in the real accumulator.

*g_req	jop = 'je'					:(g_r1)
*g_rne	jop = 'jne'					:(g_r1)
*g_rge	jop = 'jge'					:(g_r1)
*g_rgt	jop = 'jg'					:(g_r1)
*g_rle	jop = 'jle'					:(g_r1)
*g_rlt	jop = 'jl'

g_r1	genop('call','cpr_')

	genop('mov','al','byte [reg_fl]')
	genop('or','al','al')
	genop(jop,getarg(arg1))				:(opdone)

*	*   5.16 ATN

*	Arctangent of real accumulator

*	*   5.17 CHP

*	Integer portion of real accumulator

*	*   5.18 COS

*	Cosine of real accumulator

*	*   5.19 ETX

*	e to the power in the real accumulator

*	*   5.20 LNF

*	Natural logorithm of real accumulator

*	*   5.21 SIN

*	Sine of real accumulator

*	*   5.22 SQR

*	square root of real accumulat

*	*   5.23 TAN

*	Tangent of real accumulator


*	The above orders operate upon the real accumulator, and replace the contents of the 
*	accumulator with the result.

*	The result of any of the above operations is undefined or out of range, real overflow is set,
*	the contents of (RA) are undefined and the following instruction must be either ROV or RNO

*g_atn
*g_chp
*g_cos
*g_etx
*g_lnf
*g_sin
*g_sqr
*g_tan

	genop('call',op_)
							:(opdone)

*	#### 6-	 Operations on Character Values


*	Character operations employ the concept of a character pointer which
*	uses either index register XR or XL (not XS ).

*	A character pointer points to a specific character in a string of
*	characters stored CFP$C chars to a word.

*	The only operations permitted on a character pointer are LCH
*	and SCH. In particular, a character pointer may not even be moved with MOV

*	*   6.1	 PLC  _x,opv_

*	Prepare ch ptr for LCH CMC MVC,TRC MCB

*	*   6.2	 PSC  _x,opv_

*	Prepare character pointer for SCH MVC MCB

*	_opv_ can be omitted it is zero.

*	The character initially addressed is determined by the word address in _x_ and 
*	the integer offset _opv_.

*	There is an automatic implied offset of CFP$F bytes.  CFP$F is used to formally introduce 
*	into MINIMAL a value needed in translating these opcodes which, since MINIMAL itself 
*	does not prescribe a string structure in detail, depends on the choice of a 
*	data structure for strings in the MINIMAL program.  e.g_ CFP$B =
*	CFP$C = 3, CFP$F = 6, num01 = 1, XL points to a series of 4 words, abc/def/ghi/jkl,
*	then PLC XL ,=num01 points to h.

g_plc
g_psc

	fetch(w1,arg1)
	ident(arg2) genop('xor',w2,w2)
	differ(arg2) fetch(w2,arg3)
	genop('add',w1,w2,'cfp_f')			:(opdone)

*	*   6.3	 LCH  _reg,opc_

*	Load character into register

g_lch

	eq(type(arg2),09) genop('ldrb', text(arg1),  '[' substr(arg2,2,2) ']')
	eq(type(arg2),10) genop('ldrb', text(arg1),  '[' substr(arg2,2,2), const(-1) ']!');* post indexed
	eq(type(arg2),11) genop('ldrb', text(arg1),  '[' substr(arg2,2,2), const(1) ']!');* pre indexed
							:(opdone)


*	*   6.4	 SCH  _reg,opc_

*	Store character from _reg_

*	These operations are defined such that the character is right justified in register 
*	_reg_ with zero bits to the left.

g_sch

	eq(type(arg2),09) genop('strb', text(arg1),  '[' substr(arg2,2,2) ']')
	eq(type(arg2),10) genop('strb', text(arg1),  '[' substr(arg2,2,2), const(-1) ']!');* post indexed
	eq(type(arg2),11) genop('strb', text(arg1),  '[' substr(arg2,2,2), const(1) ']!');* pre indexed
							:(opdone)

*	*   6.5	 CSC  _x_

*	Complete store characters

*	This instruction marks completion of a PSC sch,SCH ...,sch sequence initiated by a
*	PSC x instruction.

*	No more SCH instructions using x should be obeyed until another PSC is obeyed.

*	It is provided solely as an efficiency aid on machines without character orders since it 
*	permits use of register buffering of chars in sch sequences.

*	Where CSC is not a no-op, it must observe restriction 2. (e.g_ in SPITBOL, *alocs* 
*	zeroises the last word of a string frame prior to SCH sequence being started so CSC 
*	must not nullify this action.)

g_csc	

	genop()						:(opdone)


*  ## CMD and CNE

*	The following instructions are used to compare two words containing CFP$C characters.

*	Comparisons distinct from BEQ BNE are provided as on some target machines, the possibility 
*	of the sign bit being set may require special action.

*	Note that restriction 2 above, eases use of these orders in testing complete strings for 
*	equality, since whole word tests are possible.

*	*   6.6	 CEQ   _opw,opw,plbl_

*	Jump to _plbl_	_opw_ eq  _opw_

g_ceq

	fetch(w1,arg1)
	fetch(w2,arg3)
	genop('adr',w3,text(arg3))
	genop('cmp',w1,w2)
	ident(incode,'ceq') genop('moveq',PC,w3)
	ident(incode,'cne') genop('movne',PC,w3)

*	*   6.7	 CNE   _opw,opw,plbl_

*	Jump to _plbl_	_opw_ ne  _opw_

g_cne	

							:(g_ceq_

*	*   6.8	 CMC  _plbl_,_plbl_

*	Compare characters

*	CMC is used to compare two character strings. CMC registers are set up as follows.

*	```
*		    (XL)	     character ptr for first string
*		    (XR)	     character pointer for second string
*		    (WA)	     character count (must be .gt. zero)
*	```

*	XL and XR should have been prepared by PLC control passes to first _plbl_ the first string is 
*	lexically less than the second string, and to the second _plbl_ the first string is lexically greater.

*	Control passes to the following instruction if the strings are identical. After executing this 
*	instruction, the values of XR and XL are set to zero and the value in (WA) is undefined.

*	Arguments to CMC may be complete or partial strings, so making optimisation to use whole word 
*	comparisons difficult (dependent in general on shifts and masking).

g_cmc

	loop_lbl = genlab()
	done_lbl = genlab()
	
	genopl(looplbl,'nop')
	fetch(w1,minarg(10,'(xl)+'))
	fetch(w2,minarg(10,'(xr)+'))
	genop('cmp',w1,w2)

	genop('ldrlt',w0,text(arg1))
	genop('movlt',PC,w0)

	genop('adrgt',w0,text(arg2))
	genop('movgt',PC,w0)

	genop('subs',wa,const(1))

	genop('adrne',w0,loop_lbl)
	genop('movne',PC,w0);* loop back if more characters
*	
	Here if same, so clear xl and xr, then fall through to next instruction

	genopl(done_lbl,'xor',xl,xl)
	genop('xor',xr,xr)
							:(opdone)

*	*   6.9	 TRC

*	Translate characters

*	TRC is used to translate a character string using a supplied translation table.
*	Before executing _TRC_ the registers are set as follows.

*	```
*		    (XL)	     char ptr to string to be translated
*		    (XR)	     char ptr to translate table
*		    (WA)	     length of string to be translated
*	```

*	XL and XR should have been prepared by PLC  The translate table consists of CFP$A 
*	contiguous characters giving the translations of the CFP$A characters in the alphabet.

*	On completion, (XR) and (XL) are set to zero and (WA) is undefined.

g_trc

	loop_lbl = genlab()
	done_lbl = genlab()
	
	genop('adr',w0,minop(0,'(xr)'));* address of translate table

	genopl(looplbl,'nop')

	fetch(w2,minarg(10,'(xl)+','char'));* get next character to translate
	genop('add',w1,w0,w2);* get addr of replacement character
	genop('ldr',w1,'[' w1 ']', 'char');* get replacement character
	genop('strb',w1,minarg(9,'(xr)');* store back replacement characte
	genop('subs',wa,const(1))

	genop('adrne',w0,loop_lbl)
	genop('movne',PC,w0);* loop back if more characters
*	
	Here when done, so clear xl and xr, then fall through to next instruction

	genopl(done_lbl,'xor',xl,xl)
	genop('xor',xr,xr)
							:(opdone)
*	*   6.10 FLC  _w_

*	Fold character to upper case

g_flc

	error('flc  not supported ')			:(opdone)

*	#### 7- Operations on Bit String Values

*	*   7.1	 ANB   _w,opw_

*	And bit string values, result in _w_

g_anb	

	reg = text(arg1)
	fetch(w1,arg2)
	genop('and',reg,reg,w1)				:(opdone)

*	*   7.2	 ORB   _w,opw_

*	Or bit string values, result in _w_

	reg = text(arg1)
	fetch(w1,arg2)
	genop('or',reg,reg,w1)				:(opdone)

g_orb	

*	*   7.3	 XOB   _w,opw_

*	Exclusive or bit string values, result in _w_

*	In the above operations, the logical connective is applied separately to each of the CFP$N bits.

g_xob	

	reg = text(arg1)
	fetch(w1,arg2)
	genop('eor',reg,reg,w1)				:(opdone)

*	*   7.4	 CMB  _w_

*	Complement all bits in _w_

*	This statement is NOT used in Minimal version of SPITBOL, so no need to translate it.

g_cmb	

	errror('unexpected/unsupported use of cmb operator')	:(opdone)

*	#### Shift operations

*	The following operations are logical shifts, not arithmetic shifts.

*	*   7.5	 RSH  _w,val_

*	Right shift _w_ by _val_ bits

g_rsh

	reg = text(arg1)
	fetch(w1,arg2)
	genop('and',reg,reg,w1)				:(opdone)

*	*   7.6	 LSH  _w,val_

*	Left shift _w_ by _val_ bits

g_lsh

	reg = text(arg1)
	fetch(w1,arg(2))
	genop('lsl',reg,reg,w1)				:(opdone)

*	*   7.7	 RSX  _w,(x)_

*	Right shift _w_ by  number of bits in _x_

g_rsx

	reg = text(arg1)
	fetch(w1,arg(2))
	genop('lsr',reg,reg,w1)				:(opdone)


*	*   7.9	 NZB  _w,plbl_

*	Jump to _plbl_ w is not all zero bits.

g_nzb	
	
	reg = text(arg1)
	genop('or',reg,reg)
	genop('adrne',w0,text(arg2))
	genop('movne,PC,w0)
	genop('jnz',getarg(arg2))
							:(opdone)

*	*   7.10 ZRB  w,_plbl_

*	Jump to _plbl_ w is all zero bits

g_zrb
	reg = text(arg1)
	genop('or',reg,reg)
	genop('adreq',w0,text(arg2))
	genop('moveq,PC,w0)
							:(opdone)
*	*   7.11 ZGB   _opn_

*	Zeroise garbage bits

*	_opn_ contains a bit string representing a word of characters from a string or 
*	some function formed from such characters (e.g_ as a result of hashing).

*	 On a machine where the word size is not a multiple of the character size,
*	 some bits in _reg_ may be undefined.

*	This opcode replaces such bits by the zero bit. ZGB is a no-op the word size is a
*	 multiple of the character size.

g_zgb

	genop('nop')
							:(opdone)

*	#### 8-	 Conversion Instructions


*	The following instructions provide for conversion between lengths in bytes and lengths in words.


*	*   8.1	 WTB  _reg_

*	Convert	 _reg_ from words to bytes.

*	That is, multiply by CFP$B . This is a no-op if CFP$B  is one.

g_wtb	

	genop('lsl',text(arg1), const('log_cfp_b'))	:(opdone)

*	*   8.2	 BTW  _reg_

*	Convert _reg_ from bytes to words by dividing _reg_ by CFP$B discarding the fraction.
*	This is a  no-op if CFP$B is one

*	The following instructions provide for conversion of one word integer values (addresses) 
*	to and from the full signed integer format.

g_btw	

	genop('lsr',text(arg1), const('log_cfp_b'))	:(opdone)

*	*   8.3	 MTI   _opn_

*	The value of _opn_ (an address) is moved as a positive integer to the integer accumulator.

g_mti	

	genop('ldr',ia, arg2)				:(opdone)

*	*   8.4	 MFI   _opn,plbl_

*	The value currently stored in the integer accumulator is moved to _opn_ as an address 
*	if it is in the range 0 to CFP$M inclusive.

*	If the accumulator value is outside this range, then the result in _opn_ 
*	is undefined and control is passed to _plbl_.

*	MFI destroys the value of (IA) whether or not integer overflow is signalled.  
*	_plbl_ may be omitted overflow is impossible.

*	The following instructions provide for conversion between real values and integer values.

g_mfi

*	last arg is optional
*	compare with cfp$m, branching if result negative

	eq(type(arg2))					:s(g_mfi.1)

*	here if label given, branch if ia not in range (ie, negative)

	genop('mov',w0,ia)
	genop('cmp',w0,w0)
	genop('adrmi',w1,text(arg2);* branch if ia negative
	genop('movmi',PC,w1)
	genop('subs',w0,ia,const('cfp_m'));
	genop('adrmi',w1,text(arg2)
	genop('movmi',PC,w1);* branch if ia greater than cfp_m
	store(ia,arg1)					:(opdone)

g_mfi.1

*	Here if no label given, so just update value of IA.

	store(ia,arg1)					:(opdone)

*	*   8.5	 ITR

*	Convert integer value in integer accumulator to real and store in real accumulator 
*	(may lose precision in some cases)

g_itr

	error('g_itr real arithmetic not supported')	:(opdone)

*	*   8.6	 RTI  _plbl_

*	Convert the real value in RA to an integer and place result in IA .  Conversion is 
*	by truncation of the fraction - no rounding occurs.

*	Jump to _plbl_ if RA out of range. *RA* is not changed in either case.

*	_plbl_ may be omitted overflow is impossible.

*	The following instructions provide for computing the length of storage required for a text string_

g_rti

	error('g_rti real arithmetic not supported')	:(opdone)

*	here if label given, branch if real too large

	genop('jc',getarg(arg1))				:(opdone)

*	*   8.8	 CTB  _w,val_

*	CTB is exactly like CTW except that the result is in bytes.

*	The following instructions provide for conversion from integers to and from numeric 
*	digit characters for use in numeric conversion routines. They employ negative integer 
*	values to allow for proper conversion of numbers which cannot be complemented.

g_ctb

	reg = text(arg1)
	genop('add',reg,reg,const('(cfp_b-1)+cfp_b*' text(arg2)))
	genop('and',reg,const('-cfp_b'))
							:(opdone)
*	*   8.9	 CVM  _plbl_

*	Convert by multiplication

*	The integer accumulator, which is zero or negative, is multiplied by 10.  WB contains the 
*	character code for a digit. the value of this digit is then subtracted from the result.

*	The result is out of range, then control is passed to _plbl_ with the result in 
*	(IA) undefined. execution of CVM leaves the result in (WB) undefined.

g_cvm	
	error('TODO ctb')				:(opdone)
	t1 = getarg(arg1)

	genop('sti_',w0)
	genop('imul',w0,'10')
	genop('jo',t1)
	genop('sub',wb,'ch_d0')
	genop('sub',w0,wb)
	genop('ldi_',w0)
	genop('jo',t1)
							:(opdone)

*	* 8.10 cvd

*	Convert by division

*	The integer accumulator, which is zero or negative, is divided by 10.
*	the quotient (zero or negative) is replaced in the accumulator.

*	The remainder is converted to the character code of a digit and placed in
*	WA. For example, an operand of -523 gives a quotient of -52 and a
*	remainder in WA of CH$D3.

g_cvd

	error('TODO cvd')				:(opdone)
	genop('cvd_')					:(opdone)

*	#### 9-	 Block Move Instructions

*	The following instructions are used for transferring data from one area of memory to another
*	in blocks.  They can be implemented with the indicated series of other macro-instructions,
*	but more efficient implementations will be possible on most machines.

*	Note that in the equivalent code sequence shown below, a zero value in WA will move at 
*	least one item, and may may wrap the counter causing a core dump in some implementations.
*	Thus WA should be greater than 0 prior to invoking any of these block move instructions.

*	*   9.1	 MVC

*	Move characters


*	Before obeying this order WA,XL ,XR should have been set up, the latter two by PLC PSC resp.
*	MVC is equivalent to the sequence

*	```
*			   mov	dumpb,WB
*			   lct	WA,WA
*		    loopc  lch	WB,(XL)+
*			   sch	WB,(XR)+
*			   bct	WA,loopc
*			   csc	XR
*			   mov	WB,dumpb

*	```

*	The character pointers are bumped as indicated and the final value of WA is undefined.

g_mvc

*	     use word move if character size is word size.
*	     if charsize is word size, convert character count to byte count for word move

	error('TODO mvc')				:(opdone)
	ne(cfp_b,cfp_c)					:s(g_mvw)
	z_suspend = 1
	genop('call',incode)
	z_suspend = 0
							:(opdone)

*	* 9.2  MVW

*		      move words


*	MVW is equivalent to the sequence

*	```
*		     opw  mov  (XR)+,(XL)+
*		     dca  WA		  WA = bytes to move
*		     bnz  WA,lo opw

*	```



*	Note that this implies that the value in WA is the length in bytes which is a multiple of CFP$B .

*	The initial addresses in XR ,XL are word addresses.

*	As indicated, the final XR ,XL values point past the new and old regions of memory respectively.

*	The final value of WA is undefined.  WA,XL ,XR must be set up before obeying MVW

g_mvw

	error('TODO mvw')				:(opdone)
	z_suspend = 1
	genop('call',incode)
	z_suspend = 0
							:(opdone)

*	*   9.3	 MWB

*	Move words backwards

*	MWB  is equivalent to the sequence

*	```
*		    loopb  mov	-(XL),-(XR)
*			   dca	WA		 WA = bytes to move
*			   bnz	WA,loopb
*	```

*	There is a requirement that the initial value in XL be at least 256 less than the value in XR .

*	The final value of WA is undefined.

*	WA ,XL , XR must be set up before obeying MWB .

g_mwb

	error('TODO mwb')				:(opdone)
	genop('call',incode)					:(opdone)

*	*   9.4	 MCB

*	Move characters backwards


*	MCB is equivalent to the sequence

*	```
*			   mov	dumpb,WB
*			   lct	WA,WA
*		    loopc  lch	WB,-(XL)
*			   sch	WB,-(XR)
*			   bct	WA,loopc
*			   csc	XR
*			   mov	WB,dumpb
*	```


*	There is a requirement that the initial value in XL be at least 256 less than the value in XR.
*	This allows an implementation in which chunks of 256 bytes are moved forward (IBM 360, ICL 1900).

*	The final value of WA is undefined.  WA,XL ,XR must be set up before obeying MCB

g_mcb

*	     use word move if character size is word size

	error('TODO mcb')				:(opdone)
	ne(cfp_b,cfp_c)					:s(g_mwb)
	genop('call',incode)				:(opdone)

*	#### 10- Operations Connected with the Stack


*	The stack is an area in memory which is dedicated for use in conjunction with the 
*	stack pointer register (XS ). As previously described, it is used by the JSR and EXI
*	instructions and may be used for storage of any other data as required.

*	The stack builds downward in this implementation.

*	The starting stack base address is passed in (XS ) at The start of execution.
	During execution it is necessary to make sure that the stack does not overflow.
*	This is achieved by executing the following instruction periodically.

*	*   10.1 CHK

*	Check stack overflow

*	After successfully executing CHK it is permissible to use up to 100 additional words 
	before issuing another chk thus CHK need not be issued every time the stack is
*	expanded. In some implementations, the checking may be automatic and CHK will have no effect.

g_chk

	error('TODO chk')				:(opdone)
	genop('cmp',xs,'lowspmin')
	genop('jb','sec06')
							:(opdone)

*	#### 11- Data Generation Instructions

*	The following instructions are used to generate constant values in the constant section 
*	and also to assemble initial values in the working storage section.
*	They may not appear except in these two sections.

*	*   11.1 DAC  _addr_

*	Assemble address constant.

*	Generates one word containing the specified one word integer value (address).

g_dac

	error('TODO dac')				:(opdone)
	t1 = type(arg1)
	genopl(thislabel,'.word',text(arg1))
							:(decend)

*	*   11.2 DIC  _integer_

*	Generates an integer value which occupies CFP$I consecutive words.

*	The operand is a digit string with a required leading sign.

g_dic

	error('TODO dic')				:(opdone)
	genopl(thislabel,'.int',text(arg1))
							:(decend)
*	*   11.3 DRC  _real_

*	Assembles a real constant which occupies CFP$R consecutive words.

*	The operand form must obey the rules for a FORTRAN real constant with the extra 
*	requirement that a leading sign be present.

g_drc

	error('TODO drc')				:(opdone)
	genop('align',8)
	t1 = text(arg1)
	t1 ? fence "+" = ""
	genopl(thislabel,'.float',t1)

*	note that want to attach label to last instruction

	t.label(cstmts[cstmts.n]) = thislabel
	thislabel =					:(opdone)


*	*   11.4 DTC  _dtext_

*	Define _text_ constant.

*	Text is started and ended with any character not contained in the characters to be 
*	assembled. The constant occupies consecutive words as dictated by the 
*	configuration parameter CFP$C .

*	Any unused chars in the last word are right filled with zeros (i.e. the character whose 
*	internal code is zero).	 The string contains a sequence of letters, digits, blanks and 
*	any of the following special characters.  =,$.(\*)/+-


*	No other characters may be used in a _dtext_ operand.

g_dtc

	error('TODO dtc')				:(opdone)
*	change first and last chars to " (assume / used in source)

	t1 = text(arg1)
	t1 tab(1) rtab(1) . t2
	t3 = remdr(size(t2),cfp_c)

*	      t2 = "'" t2 "'"
*	append nulls to complete last word so constant length is multiple
*	of word word

	dtc_i = 1
	t4 =

g_dtc.1

	t4 = gt(dtc_i, 1) t4 ","
	t4 = t4 "'" substr(t2,dtc_i,1) "'"
	le(dtc_i = dtc_i + 1, size(t2))			:s(g_dtc.1)

	t4 = ne(t3) t4 dupl(',0',cfp_c - t3)
	genopl(thislabel,'.ascii',t4)
							:(opdone)
*	*   11.5 DBC  val

*	Assemble bit string constant.

*	The operand is a positive integer value which is interpreted in binary, 
*	right justified and left filled with zero bits. Thus 5 would imply the bit string value 00...101.  

g_dbc

	error('TODO dbc')				:(opdone)
	genopl(thislabel,'.word',getarg(arg1))		:(opdone)

decend

*	here at end of dic or dac to see if want label made public

	thislabel ? rtab(1) . thislabel '		:'
*	differ(pubtab[thislabel]) genop('.globl',thislabel)
							:(opdone)

*	#### 12- Symbol Definition Instructions

*	The following instruction is used to define symbols in the definitions section.
*	 It may not be used elsewhere.

*	*   12.1 EQU  _eqop_

*	Define symbol

*	The symbol which appears in the label field is defined to have the absolute value given by the _eqop_ operand.
*	A given symbol may be defined only once in this manner, and any symbols occuring in _eqop_ 
*	must be previously defined.

g_equ

	genop('.set',thislabel ',' , text(arg1))	:(opdone)

*	*   12.2 *exp

*	Define external procedure

*	*exp* defines the symbol appearing in the label field to be the name of an external 
*	procedure which can be referenced in a subsequent JSR instruction.

*	The coding for the procedure is external to the coding of the source program in this language.
*	The code for external procedures may be referred to collectively as the operating system 
*	interface, or more briefly, osint, and will frequently be a separately compiled segment
*	of code loaded with SPITBOL to produce a complete system.

g_exp

	ppm_cases[thislabel] = text(arg1)
	genop('.extern',thislabel)
	thislabel =					:(opdone)

*	*   12.3 INP  _ptyp_,int

*	Define internal procedure

*	INP defines the symbol appearing in the label field to be the name of 
*	an internal procedure and gives its type and number of exit parameters.

*	The label can be referenced in JSR instructions and it must appear
*	labelling a PRC instruction in the program section.

g_inp

	ppm_cases[thislabel] = text(arg2)
	prc.count1 = ident(text(arg1),'n') prc.count1 + 1 :(opnext)

*	*   12.4 INR

*	Define internal routine

*	INR defines the symbol appearing in the label field to be the name of an internal routine.

*	The label may be referenced in any type of branch order and it must 
*	appear labelling a RTN instruction in the program section.


g_inr	genop('')					:(opdone)

*	### 13 - Assembly Listing Layout Instruction

*	Who uses listings these days? Who even knows what a listing is? Those were the days ...

*	*   13.1 EJC

*	Eject to next page


g_ejc							:(opnext)

*	*   13.2 TTL  text

*	Set new assembly title

*	TTL implies an immediate eject of the assembly listing to print the new title.

*	The use of TTL and EJC cards is such that the program will list neatly the 
*	printer prints as many as 58 lines per page. In the event that the printer
*	depth is less than this, or the listing contains interspersed lines (such
*	 as actual generated code), then the format may be upset.


g_ttl							:(opnext)

end
