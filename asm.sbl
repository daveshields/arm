-title mincod						: phase 2 translation from minimal tokens to 80386 code
-stitl description

* use # as start of line for full-line comment
* use // for rest of line comment
* registers are $n or $rn
* can also use @ for end-line comment
* use directive  .syntax unified


*	Copyright 1987-2012 robert b. k. dewar and mark emmer.
*	Copyright 2012-2017 david shields

*	this file is part of macro spitbol.

*	macro spitbol is free software: you can redistribute it and/or modify
*	it under the terms of the gnu general public license as published by
*	the free software foundation, either version 2 of the license, or
*	(at your option) any later version.

*	macro spitbol is distributed in the hope that it will be useful,
*	but without any warranty; without even the implied warranty of
*	merchantability or fitness for a particular purpose.  see the
*	gnu general public license for more details.

*	you should have received a copy of the gnu general public license
*	along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.


*	this program takes input file in minimal token form and produces assembly
*	code for arm processor using the 32-bit arm comands.

*	options relating to the processing of comments can be changed by modifying the source.

*	in addition to the normal minimal register complement, one scratch work
*	register, w0 is defined. see the register map below for specific allocations.

*	this program is based in part on earlier translators for the it is based in part on
*	earlier translators for the dec vax (vms and un*x) written by steve duff and
*	robert goldberg, and the pc-spitbol translator written by david shields.

*  to run under spitbol:

*	    spitbol asm.sbl

*	    reads sbl.min	    	containing tokenized source code
*	    writes sbl.asm	    	with 80386 assembly code
*	    also writes sbl.err		with err and erb error messages

*	    also reads <file>.pub   for debug symbols to be declared public

-stitl crack(line)
	define('crack(line)operands,operand,char')	:(crack_end)

*	crack is called to create a stmt plex containing the various parts of the minimal source
*	statement in line.  for conditional assembly ops, the opcode is the op, and op1 is the symbol.
*	note that dtc is handled as a special case to assure that the decomposition is correct.

*	crack prints an error and fails if a syntax error occurs.

*	crack parses stmt into a stmt data plex and returns it. it fails if there is a syntax error.

crack

	nstmts	= nstmts + 1
	op1 = op2 = op3 = typ1 = typ2 = typ3 =
	line	p.csparse				:s(return)
*	here on syntax error

	error('source line syntax error')		:(freturn)
crack_end
-stitl	chktrace()
	define('chktrace()')				:(chktrace_end)
chktrace

*						     :(return)
*	     output = 'chktrace:' iinput_lines ':' label ':' stmtout
*	     output = differ (label) 'chktrace label:' label ':'
*	     turn off skip mode when begin executable code

	clabel = inlabel
	old_z_skip = z_skip
	old_z_exec = z_exec
	old_is_exec = is_exec
	z_skip = ident(inlabel,'s_aaa') 0

*	     incode ? any(lcase)		     :s(return)

	uopcode	 = replace(incode, lcase,ucase)

*	do not trace bsw (for now)

	ident(uopcode,'bsw')				:s(return)
	is_exec = is_executable[uopcode]
	z_exec = ne(z_trace)  ident(inlabel, 's_aaa') 1
	z_exec = gt(input_lines,2186) 1

*	need to skip certain blocks since otherwise get branches that are
*	too long skip when in code that won't assemble if try to trace
*	this was discovered on a case-by-case basis.

	z_skip	= differ(inlabel) differ(skip_on[inlabel]) 1
	z_skip	= differ(inlabel) differ(skip_off[inlabel]) 0

	ne(z_skip)					:s(return)
	eq(z_exec)					:s(return)
	eq(is_exec)					:s(return)

*	here to emit trace. need to emit trace after label if there is label
*	ident(inlabel)			     :s(chktrace.1)
*	     only trace at labels since get jumps that are too removed otherwise
*	     ident(label)			     :s(return)
*	     here to emit trace code when there is label
*	     first need to emit label, then fall through

*	     stmtout ? break_ws	 . label spanws	 rem . body  :f(outstmt5)
*	     stmtout = tab body
*	     outfile = label
*	     label =
	ne(in_gcol)					:s(return)

chktrace.1

	genz()
							:(return)

chktrace_end
-sttl	const	return value of symbol defined in definition section
	define('const(iarg)val')			:(const_end)

*	If the argument is a symbol defined in the definition section then
*	return the symbol expressed as an immediate constant.
*	If the argument is an integer, return the integer as an immediate constant.

const

	const = '#' iarg				:(return)
	
	const = ident(datatype(iarg),minarg) '#' text(iarg)	:s(return)

const_end
-stitl	flush
	define('flush()')				:(flush_end)

*	here to emit  attach input label and comment to first instruction generated.

flush

*	output the current statement

	label = thislabel =
	outstmt(tstmt())				:(return)

flush_end
-stitl genz
	define('genz()')				:(genz_end)

*	generate trace instruction if needed.

genz

*	     no trace if trace has been suspended
*	     output = ne(z_suspend) 'z_suspend ' thisline

	ne(z_suspend)					:s(return)

*  only trace at label definition
*	     ident(thislabel)			     :s(return)

	z_count = z_count + 1
	gt(z_first) le(z_count,z_first)			:s(return)
	gt(z_limit)  gt(z_count, z_limit)		:s(return)

*	     always generate trace if at label definition

	z_desc = '"' replace(thisline,sepchar,' ') '"'
	outfile = tab 'zzz' tab z_count ',' input_lines ',' z_desc
	outlines = outlines + 1
							:(return)

genz_end
-stitl comregs(line)t,pre,word
	define('comregs(line)t,pre,word')		:(comregs_end)

*	map minimal register names to target register names

comregs

	line p.comregs =				:f(comregs1)
	word = eq(size(word),2) differ(t = word) t
	comregs = comregs pre word			:(comregs)

comregs1 comregs = comregs line				:(return)

comregs_end
-stitl error(text)
	define('error(text)')				:(error_end)

*	this module handles reporting of errors with the offending
*	statement text in thisline.  comments explaining
*	the error are written to the listing (including error chain), and
*	the appropriate counts are updated.

error

	output = filenami ': error: ' text ' in line ' input_lines
	output = 'this line ' thisline
* output = 'error datatype filenami ' datatype(filenami)
*	outfile = rpad(lpad(input_lines,6),size(filenami) -1) ' | ' thisline
	lasterror = output_lines
	output_lines = output_lines + 2
	le(nerrors = nerrors + 1, 10)			:s(opnext)
	output = 'too many errors, quitting'		:(end)

error_end
-stitl	fetch - load value from memory
	define('fetch(reg,iarg,kind)')			:(fetch_end)

*	load value from memory to register

fetch

	ident(datatype(iarg),'string') genop('FETCH-str' kind,reg, text(iarg))
	genop('FETCH' kind,reg,text(iarg))		:(return)
* output = 'fetch reg<' reg '> type<' type(iarg) '> text <' text(iarg) '> kind <' kind '>'
	genmem('ldr',reg,iarg,kind)			:(return)

fetch_end
-stitl genlab()

	define('genlab()')				:(genlab_end)

*	generate unique label for use in generated code

genlab

	genlab = '_l' lpad(genlabels = genlabels + 1,4,'0') :(return)

genlab_end
-stitl	genmem(argnum)
	define('genmem(op,reg,iarg,kind)base,offset')	:(genmem_end)

*	get argument to register _reg_ and return that register.
*	genmem word unless _kind_ is not null, in which case genmem character

genmem

*	val	01,02			predefined value
*	reg	07,08			register
*	opc	09,10,11		character
*	ops	03,04,09,12-15		memory reference
*	opw	03,04,08-15		full word
*	opn	03,04,07-15		one word integer, e.g., an address
*	opv	03,04,0-15,18-22	one word integer value	
*	addr	01-05			address


* output = 'genmem datatype ' datatype(iarg) ' ' type(iarg) ' ' text(iarg)
* output = 'genmem op <' op '> reg<' reg '> kind<' kind '>'

	kind = differ(kind) 'b'
	op = op kind


								:($('genmem_' type(iarg)))
genmem_1
genmem_2

	genop(op, '=' text(iarg))				:(return)

genmem_3
genmem_4
genmem_5
genmem_6

*	wlbl, clbl, elbl, plbl (all labels in text section in arm version)

	genop(op,reg,text(iarg))				:(return)

genmem_7
genmem_8

*	w,x, map register name

	genop(op,reg,text(iarg))				:(return)

genmem_9

*	(x), register indirect

	genop(op,reg, '[' text(iarg) ']')
								:(return)

genmem_10

*	(x)+, register indirect, post increment

*	ident(text(iarg),'(xs)+) genop('pop','{' reg '})	:s(return)
	
	offset = (ident(kind),'cfp_b',1)
	genop(op,reg, '[' base  '],' const(offset))		:(return)

genmem_11

*	-(x), register indirect, pre decrement

	offset = (ident(kind),'cfp_b',1)
	genop(op,reg, '[' base ','  const(offset) ']!')		:(return)

genmem_12
genmem_13

*	int(x)
*	dlbl(x)

	text(iarg) break('(') . offset '(' len(2) . base
	genop(op,reg,'[' base ',' const('cfp_b*' offset) ']')	:(return) 

genmem_14
genmem_15

*	name(x), where name is in working section

	text(iarg) break('(') . offset '(' len(2) . base
	genop(op,reg,'[' base, ',' const(offset) ']')		:(return) 

genmem_18
genmem_20
genmem_21
genmem_22

	genop('adr',reg,text(iarg))				:(return)

genmem_19

	genop('adr',reg,text(iarg))
	genop('lsl',reg,'lsl 2')				:(return)

genmem_23
genmem_24
genmem_26
genmem_27

	error('genmem type not valid, but is ' type(iarg))	:(freturn)

genmem_ok

genmem_end
-stitl genopl(gopl,gopc,gop1,gop2,gop3)
	define('genopl(gopl,gopc,gop1,gop2,gop3)')	:(genopl_end)

*	generate operation with label

genopl

	outstmt(tstmt(gopl,gopc,gop1,gop2,gop3))	:(return)

genopl_end
-stitl genop(gopc,gop1,gop2,gop3)
	define('genop(gopc,gop1,gop2,gop3)')		:(genop_end)

*	generate operation with no label

genop

	genopl(,gopc,gop1,gop2,gop3)			:(return)

genop_end
-sttl	init - initialize global constants and variables
	define('init()')				:(init_end)

*	initalize for translation
init

*	revision history:

	version = 'v1.0'

*	keyword initialization

	&anchor = 1;	&stlimit = 15000000;	&trim	= 1;  &dump = 1

	&dump = 2

*	useful constants

	letters = 'abcdefghijklmnopqrstuvwxyz'
	ucase	= letters
	lcase	= 'abcdefghijklmnopqrstuvwxyz'
	nos	= '0123456789'
	tab	= char(9)

*	sepchar separates fields in input file

	sepchar = '|'

*	default the parameter string if none present

	fileprefix = "sbl"

*	cfp_b is bytes per word, cfp_c is characters per word
*	these should agree with values used in translator

	cfp_b = 4
	log_cfp_b = '2'

	cfp_c = 4
	log_cfp_c = '2'

*	target register assignments

*	Map registers to their minimal names, since can use gnu as directive .req
*	to map to the actual registers to be used.

*	w0 is temp register

	w0 = 'w0'; w1 = 'w1'; w2 = 'w2'
	wa = 'wa'; wb = 'wb'; wc = 'wc'
	xl = 'xl'; xr = 'wr'; 
	xs = 'xs'; xt = xs
	ia = wc
	cp = 'cp' 

*	pc is the program counter. We use PC when explicitly maniupulating the program branch, typically
*	as part of a branch.

	pc = 'pc'
	PC = pc

* symbolic target assignments

*	real_op maps minimal real opcode to machine opcode

	real_op = table(10)
	real_op['adr'] = 'fadd'
	real_op['atn'] = 'fpatan'
	real_op['chp'] = 'frndint'
	real_op['cos'] = 'fcos'
	real_op['dvr'] = 'fdiv'
	real_op['ldr'] = 'fld'
	real_op['mlr'] = 'fmul'
	real_op['ngr'] = 'fchs'
	real_op['sbr'] = 'fsub'
	real_op['sin'] = 'fsin'
	real_op['sqr'] = 'fsqrt'
	real_op['str'] = 'fst'

config_done


*	set z_trace to enable instruction by instruction trace
	z_trace = 1
	z_trace = 0
*	z_limit is maximum number of calls to be generated if non-zero
	z_limit = 000
*	set z_first non-zero to skip first number of instructions that would
*	 generate trace
	z_first = 0
*	will set in_executable when in part of program where executable
*	instructions may occur
	z_exec = 0

*	z_suspend is set to temporarily disable the trace.
	z_suspend = 0
*	set in_skip when should not insert trace code, else assembly errors result.
*	start with skip on, turn off when see first start of code.
	z_skip = 1
*	skip_on and skip_off are labels indicating the start and end,
*	respectively, of sections of the code that should not be traced,
*	usually because they contain a loop instruction that won't
*	compile if too much trace code is inserted.
	skip_on = table(50)
	skip_off = table(50)

*	skip_init('start:ini03')
	skip_init('gbcol:gtarr')
*	skip_init('gtn01:gtnvr')
*	skip_init('bpf05:bpf07')
*	skip_init('scv12:scv19')
*	skip_init('exbl1:exbl2')
*	skip_init('exbl5:expan')
*	skip_init('prn17:prn18')
*	skip_init('inarg11:inarg13')
*	skip_init('oex13:oexp2')
*	skip_init('oex14:oexp6')
*	skip_init('bdfc1:b_efc')
*	skip_init('sar01:sar10')
*	skip_init('srpl5:srpl8')
*	skip_init('pflu1:pflu2')
*	skip_init('prpa4:prpa5')
*	skip_init('prn17:prn18')
*	skip_init('prtvl:prtt1')
*	skip_init('trim4:trim5')
*	skip_init('prnl1:prnl2')
*	skip_init('prtarg1:prtmi')
*	skip_init('srpl5:srpl8')

*	data structures

*	minarg represents an argument to minimal instruction. _type_ is the
*	argument's type as operands format of the minimal specification.
*	_text_ is the actual text of the argument.

	data('minarg(type,text)')

*	following instances of minarg used for character operations.

	arg_xl = minarg(7,'xl')
	arg_xli = minarg(7,'xl')
	arg_xli = minarg(9,'(xl)')
	arg_xlp = minarg(10,'(xl)+')
	arg_mxl = minarg(11,'-(xl)')

	arg_xr = minarg(7,'xr')
	arg_xri = minarg(9,'(xr)')
	arg_xrp = minarg(10,'(xr)+')
	arg_mxr = minarg(11,'-(xr)')

	arg_xsp = minarg(9,'(xs)')
	arg_xsp = minarg(10,'(xs)+')
	arg_mxs = minarg(11,'-(xs)')

*	rcode is used to hold return code value from subroutine call.

	rcode = minarg(5,'_rc_')

	data('tstmt(t.label,t.opc,t.op1,t.op2,t.op3,t.comment)')

	sectnow = 0

*	ppm_cases gives count of ppm/err statments that must follow call to a procedure

	ppm_cases = table(50,,0)

	p.comregs = break(letters) . pre span(letters) . word

*	exttab has entry for external procedures

	exttab = table(50)

*	labtab records labels in the code section, and their line numbers

	labtab = table(500)

*	genlabels is count of generated labels (cf. genlab)

	genlabels = 0

*	initialize variables

	labcnt = output_lines = input_lines = nstmts = ntarget = nerrors = 0
	lastopc = lastop1 = lastop2 =
	data_lc = 0
	max_exi = 0

*	initial patterns

*	p.csparse parses tokenized line
	p.csparse = sepchar break(sepchar) . inlabel
.	sepchar break(sepchar) . incode
.	sepchar break(sepchar) . iarg1
.	sepchar break(sepchar) . iarg2
.	sepchar break(sepchar) . iarg3
.	sepchar break(sepchar) . incomment
	sepchar rem . slineno

	pifatal = initmap(
.	'aov:1 beq:1 bne:1 bge:1 bgt:1 bhi:1 ble:1 blo:1 blt:1 bne:1 bnz:1 ceq:1 cne:1 mfi:1 nzb:1 zrb:1 ')

*	trace not working for mvc (x64)

	is_executable = initmap(
+	'add:1 adi:1 adr:1 anb:1 aov:1 atn:1 '
+	'bct:1 beq:1 bev:1 bge:1 bgt:1 bhi:1 ble:1 blo:1 blt:1 bne:1 bnz:1 bod:1 '
+	'brn:1 bri:1 bsw:1 btw:1 bze:1 ceq:1 chk:1 chp:1 cmb:1 cmc:1 cmp:1 cne:1 csc:1 '
+	'cos:1 ctb:1 ctw:1 cvd:1 cvm:1 dca:1 dcv:1 eti:1 dvi:1 dvr:1 erb:1 esw:1 etx:1 flc:1 '
+	'ica:1 icp:1 icv:1 ieq:1 ige:1 igt:1 ile:1 ilt:1 ine:1 ino:1 iov:1 itr:1 jmp:1 '
+	'jsr:1 lch:1 lct:1 lcp:1 lcw:1 ldi:1 ldr:1 lei:1 lnf:1 lsh:1 lsx:1 mcb:1 mfi:1 mli:1 mlr:1 '
+	'mnz:1 mov:1 mti:1 mvw:1 mwb:1 ngi:1 eti:1 ngr:1 nzb:1 orb:1 plc:1 prc:1 psc:1 '
+	'req:1 rge:1 rgt:1 rle:1 rlt:1 rmi:1 rne:1 rno:1 rov:1 rsh:1 rsx:1 rti:1 rtn:1 sbi:1 sbr:1 '
+	'sch:1 scp:1 sin:1 sqr:1 ssl:1 sss:1 sti:1 str:1 sub:1 tan:1 trc:1 wtb:1 xob:1 zer:1 '
+	'zgb:1 zrb')

*	various constants

	comment.delim = ';'

*	optim.tab flags opcodes capable of participating in or optimization in outstmt routine.

	optim.tab = table(10)

	optim.tab<"and"> = optim.tab<"add"> = optim.tab<"sub"> =
.	optim.tab<"neg"> = optim.tab<"or">  = optim.tab<"xor"> =
.	optim.tab<"shr"> = optim.tab<"shl"> = optim.tab<"inc"> = 
.	optim.tab<"dec"> = 1

*	other definitions that are dependent upon things defined in the machine definition file,
*	and cannot be built until after the definition file has been read in.

*	p.outstmt examines output lines for certain types of comment contructions

	fillc	  = (ident(compress) " ",tab)
	p.outstmt = (break(fillc) . label span(fillc)) . leader
+			comment.delim rem . comment
	p.alltabs = span(tab) rpos(0)

	filenami = 'sbl.lex'
	input(.infile,1,filenami)			:s(inputok)

inputok

	report(filenami, 'input lex file')

*	associate output files.

	filenamo = 'sbl.asm'
	output(.outfile,2,filenamo)			:s(outputok)
	output = '  cannot open asm file: ' filenamo	:(end)

outputok

	output = report(filenamo,'output asm file')

*	open file for compilation of minimal err and erb messages

	output(.errfile,3, fileprefix ".err")		:s(err_ok)
	output = "  cannot open error message file: " fileprefix ".err":(end)
err_ok

*	will have havehdr non-null if more remains to copy out at end.

							:(nopub)
*	read in pub file if it exists.	this contains a list of symbols to
*	be declared public when encountered.

	pubtab = table(2)
	input(.pubfile,5, fileprefix ".pub")		:f(nopub)
	pubtab = table(101)

pubcopy

	line = pubfile					:f(pubend)
	pubtab[line] = 1				:(pubcopy)

pubend

	 endfile(5)

nopub

*	get file name

*	get definition file name following token file name, and flags.

*	fileprefix ? break(';:') . fileprefix len(1) 
*.	(break(';:') | rem) . target
*.	((len(1) rem . flags) | '')

*	$replace(target,lcase,ucase) = 1

*	parse and display flags, setting each one's name to non-null value (1).
							:(flgs.skip)
flgs

	flags ? ((len(1) break(';				:')) . flag len(1)) |
.	 ((len(1) rem) . flag) =			:f(flgs2)
	flag = replace(flag,lcase,ucase)
	output = "  flag				: " flag
	$flag = 1					:(flgs)

flgs.skip

flgs2
							:(return)
init_end
-stitl	isreg(iarg)
	define('isreg(iarg)c')				:(isreg_end)

*	succeeds if _iarg_ is a minimal register name, fails otherwise.

isreg

* output = 'isreg datatype ' datatype(iarg) ' <' datatype(iarg) '>'
	ge(type(iarg),7) le(type(iarg),8)		:f(freturn)s(return)

isreg_end
-stitl initmap(str)
	define('initmap(str),index,val')		:(initmap_end)

*	this routine is called to initialize a table from a string of index/value pairs.

initmap

	initmap = table(size(str))

initmap.1

	str	(break('[') $ index len(1) break(']') $ val len(1)) = :f(return)
	val	= ident(val,lastval) lastval
	lastval = val
	initmap[index] = val				:(initmap.1)

initmap_end
-stitl include(filename)

*	copy contents of _filename_ to the output file.

	define('include(filename)includefile,line')	:(include.end)

include

	input(.includefile,4,filename)			:s(include.next)
	error('cannot open include file ' filename)	:(return)

include.next

	outfile = includefile				:s(include.next)
	endfile(4)					:(return)

include.end
-stitl	jump	jump if condition met
	define('jump(cond,iarg)base,lbl,reg,offset')	:(jump_end)

*	jump to address given by _iarg_ if condition _cond_ is true.
*	Jump is effected by moving the desired address to the program counter PC.

jump

*	val	01,02			predefined value
*	reg	07,08			register
*	opc	09,10,11		character
*	ops	03,04,09,12-15		memory reference
*	opw	03,04,08-15		full word
*	opn	03,04,07-15		one word integer, e.g., an address
*	opv	03,04,0-15,18-22	one word integer value	
*	addr	01-05			address

*	Some minimal labels end encoded as datatype by the scanner, others aren't.

	lbl = (ident(datatype(iarg),'minarg') text(iarg),iarg)
	typ = (ident(datatype(iarg),'minarg') type(iarg),6)
* output = 'jump typ <' typ '> lbl <' lbl '>'
							:($('jump_' typ))
jump_5
jump_6

* 	elbl,pbl

*	genop('adr' cond,w0,lbl)
	genop('mov' cond,pc,lbl)			:(return)

jump_7
jump_8

*	w,x, map register name

	genop('mov' cond, pc, text(iarg))		:(return)

jump_9

*	(x), register indirect

	fetch(w0,iarg)
	genop('mov' cond, pc, w0)			:(return)

jump_10
jump_11

*	(x)+, register indirect, post increment
*	-(x), register indirect, pre decrement

	fetch(w0,iarg)	
	genop('mov' cond, pc, '[' w0 ']')		:(return)	

jump_12
jump_13

*	int(x)
*	dlbl(x)

	fetch(w0,iarg)
	genop('mov' cond, pc, '[' w0 ']')		:(return)

jump_err
jump_1
jump_2
jump_3
jump_4
jump_14
jump_15
jump_16
jump_17
jump_18
jump_19
jump_20
jump_21
jump_22
jump_25
jump_26
jump_27

* output = 'datatype jump arg ' datatype(iarg)
	error('fetch type not valid, but is ' type(iarg))	:(freturn)

jump_end
-stitl prcent(n)
	define('prcent(n)')				:(prcent_end)

prcent prcent = 'prc_+cfp_b*' ( n - 1)			:(return)

prcent_end
-stitl outstmt(ostmt)label,opcode,op1,op2,op3,comment,line)
	define('outstmt(ostmt)line,label,opcode,op1,op2,op3,comment,t,stmtout')
.			:(outstmt_end)

*	outstmt is used to send a target statement to the output file.

outstmt 

*	clear label if definition already emitted

	label = t.label(ostmt)
	label = ident(label, lastlabel)

outstmt1

*	attach source comment to first generated instruction

	differ(comment)					:s(outstmt2)
	ident(tcomment)					:s(outstmt2)
	comment = tcomment; tcomment =

outstmt2

	opcode = t.opc(ostmt)
	op1 = t.op1(ostmt)
	op2 = t.op2(ostmt)
	op3 = t.op3(ostmt)
	differ(compress)				:s(outstmt3)
*	output = datatype(op1) ' ' datatype(op2) ' ' datatype(op3)
* output = ' opcode ' opcode ' op1 <' op1  '> op2 <' op2  '>'
* output = differ(op3)  output  '  op3 <' op3 '>'
	line = rpad( rpad(label,7) ' ' rpad(opcode,4) ' '
.		  (ident(op1), op1
.			(ident(op2), ',' op2
.				(ident(op3), ',' op3))) ,27)
							:(outstmt4)
outstmt3

	line = label tab opcode tab
.		  (ident(op1), op1
.		    (ident(op2), ',' op2
.		      (ident(op3), ',' op3)))

outstmt4

	line = trim(line)
	line = le(size(line),48) rpad(line,48) '; ' comment:s(outstmt5)
	line = le(size(line),56) rpad(line,56) '; ' comment:s(outstmt5)
	line = line '; ' comment

outstmt5
**
**	send text to output file if not null.

*	     line = replace(trim(line),'$','_')

	eq(z_trace)					:s(outstmt6)

*	     here if trace code desired for executable instructions

	chktrace()

outstmt6

* output =  line
	outfile = line
	ntarget = ntarget + 1
	output_lines = output_lines + 1

*	record code labels in table with delimiter removed.
	(ge(sectnow,5) differ(thislabel))		:f(return)
	label ? break(':') . label			:f(return)
	labtab<label> = output_lines			:(return)

outstmt_end
-stitl prsarg(iarg)
	define('prsarg(iarg)l1,l2')			:(prsarg_end)
prsarg

	prsarg = minarg(0)
	iarg break(',') . l1 ',' rem . l2		:f(return)
	prsarg = minarg(convert(l1,'integer'),l2)	:(return)

prsarg_end
-stitl readline()
	define('readline()')				:(readline_end)

*	this routine returns the next statement line in the input lex file
*	to the caller.	it never fails.	 if there is no more input,
*	then a minimal end statement is returned.
*	comments are passed through to the output file directly.

readline

	readline = infile				:f(readline_eof)

* output = 'readline <' readline '>'
	input_lines  = input_lines + 1
	ident( readline )				:f(readline_2)

	outfile = readline
	output_lines = output_lines + 1			:(readline)

readline_2
* output = readline
	lne(substr(readline,1,1 ),'*' )			:s(return)

*	Here if comment.

	z_skip = ident(readline,'*z+') 0		:s(readline)
	z_skip = ident(readline,'*z-') 1		:s(readline)

	outfile = ';' substr(readline,2)
	output_lines = output_lines + 1			:(readline)

readline_eof

   readline = '	       end'				:(return)

readline_end
-stitl	report(num,text)

	define('report(num,text)')			:(report_end)

report

	output = rpad('	 ' text ':',30) num		:(return)

report_end
	define('skip_init(s)on,off')			:(skip_init_end)

*	initialize the skip table used for instruction trace.

skip_init	s break(':') . on ':' rem . off		:f(return)

	skip_on[on] = 1
	skip_off[off] = 1				:(return)

skip_init_end
-stitl	store - load value from memory
	define('store(reg,iarg,kind)')			:(store_end)

*	store value from register to memory 

store

	ident(datatype(iarg),'string') genop('STORE-str' kind,reg, text(iarg))
	genop('STORE' kind,reg,text(iarg))		:(return)
* output = 'store reg<' reg '> type<' type(iarg) '> text <' text(iarg) '> kind <' kind '>'
	genmem('ldr',reg,iarg,kind)			:(return)

store_end
-stitl main program

	output = 'start main program execution DS'
*	here follows the driver code for the "main" program.

	init()

*	loop until program exits via g_end

*	opnext is invoked to initiate processing of the next line from readline_. After doing this,
*	opnext branches to the generator routine indicated for this opcode if there is one.

*	the generators all have entry points beginning with "g_", and can be considered a logical
*	extension of the opnext routine. the generators have the choice of branching back to cause
*	the thisstmt plex to be sent to outstmt, or or branching to opnext, in which case the generator
*	must output all needed code itself.

*	the generators are listed in a separate section below.

*	&trace = 2000
*	&ftrace = 1000
*	&profile = 1

	include('int.h')
	include('int.dcl')

*	Main loop - read next line and generate necessary code for it.

	&dump = 2
opnext

	 thisline = readline()
	 crack(thisline)				:f(opnext)
	 op_ = incode '_'

*	append ':' after label if in code or data.

*	output label of executable instruction immediately if there is one, as it simplifies later
*	processing, especially for tracing_

	ident(inlabel)					:s(opnext.1)
	thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)

*	keep the label as is is not in executable code

	lt(sectnow,5)					:s(opnext.1)

	ident(incode,'ent')				:s(opnext.1)
	outfile = thislabel
	outlines = outlines + 1

*	set lastlabel so can check to avoid emitting duplicate label definitions

	lastlabel = thislabel

*	clear out label info once generated

	label = thislabel =

opnext.1

	thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)
	arg1 = prsarg(iarg1)
	arg2 = prsarg(iarg2)
	arg3 = prsarg(iarg3)
	tcomment = comregs(incomment) '} ' incode ' ' text(arg1) ' ' text(arg2) ' ' text(arg3)
	argerrs = 0
* output = 'bad incode ' incode
							:($('g_' incode))
*	here if bad opcode

op_error

	error('bad op-code')				:(opnext)

*	generate tokens.

ds.typerr

	error('operand type zero')			:(opnext)
-stitl generators

* GENERATORS

*	### 1-	Basic Instruction Set

*	1.1	 MOV   _opn,opv_  move one word value

*	MOV causes the value of operand _opn_ to be set as the new contents
*	of operand location _opv_. In the case where _opn_ is not an index
*	register, any value which can normally occupy a memory word
*	(including a part of a multiword real or integer value) can be
*	transferred using MOV. If the target location _opn_ is an index register,
*	then _opv_ must specify an appropriate one word value or operand
*	containing such an appropriate value.

g_mov

*	process register to register directly, do other moves by load and
*	store, deferring any optimization until after bootstrap.

	isreg(arg1) isreg(arg2) 			:s(g_mov_reg_reg)f(g_mov_other_other)

*	ident(text(arg1),'-(xs)')			:s(g_mov_push)
	isreg(arg1)					:s(g_mov_reg_other)

*	here is neither argument is register

g_mov_other_other
	
	fetch(w2,arg2)
	store(w2,arg1)					:(opdone)

g_mov_reg_reg

	genop('mov',text(arg1),text(arg2))		:(opdone)

g_mov_reg_other

	fetch(text(arg1),arg2)				:(opdone)


g_mov_push

	fetch(w0,arg)
	genop('push', '{' w0 '}')			:(opdone)


*	* 1.2  BRN  _plbl_    unconditional branch

*	BRN causes control to be passed to the indicated label in
*	the program section.

g_brn

	jump(,text(arg1))				:(opdone)

*	1.3  BSW  _x,val,plbl_    branch on switch value

*	BSW IFF,ESW provide a capability for a switched branch similar to a
*	fortran computed goto.  The _val_ on the BSW instruction is the
*	maximum number of branches. the value in x ranges from zero up to
*	but not including this maximum. each IFF provides a branch.

*	_val_ must be less than that given on the BSW and control goes to
*	_plbl_ if the value in x matches.  If the value in x does not correspond
*	to any of the IFF entries, then control passes to the _plbl_ on the BSW.

*	The  _plbl_ operand may be omitted if there are no values missing from the list.

*	IFF and ESW may only be used in this context. Execution of BSW may destroy the contents of _x_.

g_bsw

	z_suspend = 1

	reg = text(arg1)
	fetch(w2,arg2)
	t2 = genlab()
	ident(text(arg3))				:s(g_bsw1)

*	Here if _plbl_, so generate branch to it if out or range

	genop('cmp',reg,w2)
	jump('ge',arg3)

g_bsw1

*  here after default case check (if needed).


	genop('ldr',pc,'[' reg ',cfp_b*' const(text(arg2)) ']')
	z_suspend = 0
							:(opdone)

*	* 1.4  IFF  _val,plbl_	      provide branch for switch

*	```
*		    IFF	 val,_plbl_	...
*		    ...
*		    ...
*	```

*	Note that the lowest IFF entry value for _val_ is always zero. The IFF statements have been
*	sorted into the proper order by the lexical scanner.

g_iff

	genop('.word', plbl)				:(opdone)


*	* 1.5  ESW	end of branch switch table

g_esw
							:(opdone)

*	*   1.6	 ENT  _val_ define program entry point

*	The symbol appearing in the label field is defined to be a program entry
*	point which can subsequently be used in conjunction with the BRI
*	instruction, which provides the only means of entering the code. 

g_ent

*	entry points are stored in byte before program entry label last arg is
*	optional, in which case no initial 'db' need be issued. we force
*	odd alignment so can distinguish entry point addresses from block
*	addresses (which are always even).

*	note that this address of odd/even is less restrictive than the minimal
*	definition, which defines an even address as being a multiple of
*	cfp_b * 4, and an odd address as one that is not a multiple of
*	cfp_b (ends in 1, 2, or 3).  the definition here is a simple odd/even,
*	least significant bit definition. that is, for us, 1 and 3 are odd,
*	2 and 4 are even.

*	Note that it may be possible to use the byte before program as ARM V7
*	archiecture supports LDRD and STRB on bytes. Need to investigate,but
*	for now am disabling these instructions.

*	As a consequence operations BEV and BOD need not be implemented, as
*	entry point is implemented as full word.


	genop('.align',2)
	differ(text(arg1))				:s(g_ent.1)
	genop('nop')
							:(g_ent.2)
g_ent.1

	genop('word',text(arg1))

g_ent.2

	outlines = outlines + 2
	genopl(thislabel)
	
*	here to see if want label made public

	thislabel ? rtab(1) . thislabel '		:'
*	(differ(pubtab[thislabel]), differ(debug)) genop('.global',thislabel)
	thislabel =					:(opdone)

*	*   1.7	 BRI   _opn_	  branch indirect

*	_opn_ contains the address of a program entry point (see ent).
*	control is passed to the executable code starting at the entry point
*	address.  _opn_ is left unchanged.

g_bri

	fetch(w1,arg1)
	jump(,w1)				:(opdone)

*	*   1.8	 LEI  _x_	  load entry point identification

*	_x_ contains the address of an entry point for which an identifying value was
*	given on the the ENT line. LEI replaces the contents of _x_ by this value.

g_lei

	fetch(w1,arg1)
	genop('ldr','[' w1 ', ' const(-cfp_b) ']')	:(opdone)

*	*   1.9	 JSR  _pnam_	  call procedure _pnam_

g_jsr

	jsr_proc = text(arg1)

	genop('bl',text(arg1))

*	get count of following ppm statements

	jsr_count = ppm_cases[jsr_proc]
	eq(jsr_count)					:s(opdone)
	z_suspend = 1
	jsr_calls = jsr_calls +	 1
	jsr_label = 'call_' jsr_calls
	jsr_label_norm = jsr_label
	fetch(w0,rcode) 
	genop('subs',w0,const(1))
	store(w0,rcode)
	jump('pl',jsr_label_norm)
	z_suspend = 0

*	generate branch around for ppms that will follow. Take the branch if normal return (r1==0)

							:(opdone)

*	*   1.10 PPM  _plbl_	  provide exit parameter

*	```
*		    PPM	 _plbl_		...
*		    ...
*		    PPM	 _plbl_		...
*	```

*	JSR causes control to be passed to the named procedure. _pnam_ is the label on a PRC
*	statement elsewhere in the program section (see prc) or has been defined using an *exp* instruction.

*	The PPM exit parameters following the call give names of program locations (_plbl_-s) to
*	which alternative EXI returns of the called procedure may pass control.

*	They may optionally be replaced by error returns (see err). the number of exit parameters
*	following a JSR must equal the int in the procedure definition.

*	The operand of PPM may be omitted if the corresponding EXI return is certain not to be taken.

g_ppm							

*	PPM and ERR are handled the same way, so jump to g_err code.

							:(g_err)

*	*   1.11 PRC  _ptyp,int_  define start of procedure

*	The symbol appearing in the label field is defined to be the name of a procedure for use with JSR a
*	procedure is a contiguous section of instructions to which control may be passed with a JSR instruction.

*	This is the only way in which the instructions in a procedure may be executed.

*	It is not permitted to fall into a procedure.  Procedures should be named in section 0 INP statements.

*	_int_ is the number of exit parameters (PPM-s) to be used in JSR calls.


g_prc

*	generate public declaration
*	     t1 = thislabel
*	     t1 ? rtab(1) . t1 ':'
*	     genop()
*	     genop('.globl',t1)

	prc.args = text(arg2)
	ppm_cases[thislabel] = text(arg2)
	thislabel =
	max_exi = gt(prc.args,max_exi) prc.args
	prc.type = text(arg1)			:($('g_prc.' prc.type))

g_prc.e
g_prc.r							:(opdone)

g_prc.n

*	store return address in reserved location

	prc.count = prc.count + 1
	fetch(w0,arg_mxs);* pop from stack
	store(w0, minarg(5,prcent(prc.count)))			:(opdone)

*	*   1.12 EXI  _int_	  exit from procedure


*	The PPM and ERR parameters following a JSR are numbered starting from 1.

*	EXI int causes control to be returned to the int-th such param. EXI 1 gives control to the
*	_plbl_ of the first PPM after the JSR if _int_ is omitted, control is passed back past the
*	last exit parameter (or past the JSR if there are none).

*	For _r and_ _e_ type procedures, the stack pointer XS must be set to its appropriate entry
*	value before executing an EXI instruction.

*	In this case, EXI removes return points from the stack if any are stored there so that the
*	stack pointer is restored to its calling value.

g_exi

	t2 = prc.type; t3 = text(arg1)

*	if type r or e, and no exit parameters, just return

	differ(t2,'n') eq(prc.args)	genop('mov',pc,lr) :s(opdone)
	t3 = ident(t3) '0'
	genop('mov',w0,const(t3))
	store(w0,rcode)
	ident(t2,'n')					:s(g_exi.1)
	genop('mov',pc,lr)				:(opdone)

g_exi.1

	jump(, prcent(prc.count))
							:(opdone)

*	*   1.13 ENP  define end of procedure body

*	ENP delimits a procedure body and may not actually be executed, hence it must have no label.

g_enp	genop()						:(opdone)

*	*   1.14 ERR  _int,text_  provide error return

*	ERR may replace an exit parameter (PPM) in any procedure call. The int argument is a unique
*	error code in 0 to 899.

*	The text supplied as the other operand is arbitrary text in the FORTRAN character set and may
*	be used in constructing a file of error messages to be used by the error handling code.

*	In the event that an EXI attempts to return control via an exit parameter to an ERR control
*	is instead passed to the first instruction in the error section (which follows the program
*	section) with the error code in WA.

g_err

*	Here with return code in _rcode_. it is zero for normal return and positive for error return.
*	Decrement the value. if it is negative then this is normal return. otherwise, proceed, decrementing
*	_rcode_ until it goes negative,and then take the appropriate branch.


	t1 = text(arg1)

*	branch to next case if rcode code still not negative.

	ident(incode,'ppm')				:s(g_ppm.loop)
	count.err =  count.err + 1
	errfile =   text(arg1) ' ' text(arg2)
	max.err = gt(t1,max.err) t1
							:(g_ppm.loop)

g_ppm.loop.next

	genopl(lab_next ':')
	jsr_count = jsr_count - 1
	z_suspend = eq(jsr_count) 0
	eq(jsr_count) genopl(jsr_label_norm ':')	:(opdone)

g_ppm.loop

	lab_next = genlab()
	fetch(w0,rcode)
	genop('subs',w0,w0,const(1))
	jump('pl',lab_next)

	ident(incode,'ppm')				:s(g_ppm.loop.ppm)

*	here if error exit via exi. set rcode to exit code and jump to handler with error code in _rcode_

g_ppm.loop.err

* output = 'ppm.loop ' t1
	fetch(w0,minarg(1,const(t1)))
	store(w0,rcode)
	jump(,'err_')
							:(g_ppm.loop.next)
g_ppm.loop.ppm

*	check each ppm case and take branch if appropriate

	ident(text(arg1))				:s(g_ppm.2)
	count.ppm = count.ppm + 1
	jump(,arg1)
							:(g_ppm.loop.next)

g_ppm.2

*	a ppm with no arguments, which should never be executed, is
*	translated to err 299,internal logic error: unexpected ppm branch

	t1 = 299
	errfile =  t1 ' internal logic error		: unexpected ppm branch'
							:(g_ppm.loop.err)

*	*   1.15 ERB  _int,text_  error branch

*	This instruction resembles ERR except that it may occur at any point
*	where a branch is permitted. It effects a transfer of control to the
*	error section with the error code in WA.

g_erb
	errfile =  text(arg1) ' ' text(arg2)

*	set rcode to error code and branch to error handler

	genop('mov',w0,const(text(arg1)))
	store(w0,rcode)
	jump(,'err_')					:(opdone)

g_ssl
g_sss
g_rtn

	genop()						:(opdone)

*	real operations

*	lch requires separate cases for each first operand possibility.

*	*   7.8	 LSX  _w,(x)_

*	Left shift _w_ by the  number of bits in _x_


*	The above shifts are logical shifts in which bits shifted out are lost
*	and zero bits supplied as required. The shift count is in the
*	range 0-CFP$N .

g_lsx

	error('lsx not supported')

g_zzz


	genop('zzz',text(arg1))				:(opdone)


*	*   8.7	 CTW  _w,val_

*	This instruction computes the sum (number of words required to store 
*	w characters) + (val). the sum is stored in _w_.

*	For example, CFP$C is 5, and WA contains 32, then CTW WA,2
*	gives a result of 9 in WA.


g_ctw

*	assume cfp_c chars per word

	fetch(w1,arg1)
	genop('add',w1,const('(cfp_c - 1) + cfp_c *' text(arg2)))
	genop('lsr',w1,w1,const('log_cfp_c'))
							:(opdone)
g_sec

	genop('')
	sectnow = sectnow + 1				:($("g_sec." sectnow))

*  procedure declaration section

g_sec.1

	genop('.text')
	genop('.global','sec01')
	genopl('sec01' ':')				:(opdone)

*	definitions section

g_sec.2

	genop('.global','sec02')
	genopl('sec02' ':')				:(opdone)

*  constants section

g_sec.3

	genop('.global','sec03')
	genopl('sec03' ':')				:(opdone)

*  working variables section

g_sec.4

	genop('.global','esec03')
	genopl('esec03' '				:')
	genop('.global','sec04')
	genopl('sec04' ':')				:(opdone)

*	here at start of program section.  If any n type procedures, put out entry-word block
*	declaration at end of working storage

g_sec.5

*	emit code to indicate in code section.

	genop('.global','esec04')
	genopl('esec04' '				:')

	genopl('prc_')
	genop('.rept' tab prc_count1)
	genop('.word' tab '0')
	genop('endr')

	genop('.global','lowspmin')
	genopl('lowspmin','.word', 0)

	genop('.global','end_min_data')
	genopl('end_min_data')
	genop('.global','sec05')
	genopl('sec05')					:(opdone)

*	stack overflow section.	 output exi__n tail code

g_sec.6

	genop('.global','sec06')
	genopl('sec06')
							:(opdone)

*	error section.	produce code to receive erb's

g_sec.7

	genop('.global','sec07')
	genopl('sec07' '				:')
	flush()
*	error section.	produce code to receive erb's

*	allow for some extra cases in case of max.err bad estimate

	n1 = max.err + 8
*	output = '  max.err ' max.err
	genopl('err_')
	genop('mov',w0,wa);* set up to exchange wa and rcode
	fetch(w0,rcode)
	store(wa,rcode)
	genop('mov',wa,w0)				:(opdone)



opdone

	flush()						:(opnext)
opdone.end
g_end

	&dump = 2
	&dump = 0
	ident(havehdr)					:s(g_end.2)

*	here to copy remaining part from hdr file

g_end.1

	line = hdrfile					:f(g_end.2)
	ntarget = ntarget + 1
	output_lines = output_lines + 1
	outfile = line					:(g_end.1)

g_end.2

*	here at end of code generation.

	endfile(1)
	endfile(2)
	endfile(3)
	report(input_lines,	'lines read')
	report(nstmts,		'statements processed')
	report(ntarget,		'target code lines produced')
	report(&stcount,	'spitbol statements executed')
	report(max.err,		'maximum err/erb number')
	report(prc.count1,	'prc count')
	output	= '  ' gt(prc.count,prc.count1)
.	  '  differing counts for n-procedures:'
.	  ' inp ' prc.count1 ' prc ' prc.count
	differ(nerrors) report(nerrors,'errors detected')

	errfile = '* ' max.err ' maximum err/erb number'
	errfile	= '* ' prc.count ' prc count'
.		differ(lasterror) '  the last error was in line ' lasterror

	&code	= ne(nerrors) 2001
	report(collect(), 'free words')
							:(end)
*	1.16 ICV   _opn_  increment value by one

*	ICV increments the value of the operand by unity.

g_icv

	fetch(w1,arg1)
	genop('add',w1,const(1))			:(opdone)

*	1.17 DCV   _opn_	  decrement value by one

*	DCV decrements the value of the operand by unity.

g_dcv

	fetch(w0,arg1)
	genop('dec',w0,const(1))			
	store(w0,arg1)
							:(opdone)

*	1.18 ZER   _opn_

*	ZER is equivalent to MOV =zeroe,_opn_

g_zer

	genop('xor',w1,w1)
	store(w1,arg1)
							:(opdone)

*	*   1.19 MNZ   _opn_ 

*	Make operand non zero.  Any non-zero collectable value may used, for which the opcodes
*	_bnz_/_bze_ will branch/fail to branch.


g_mnz

	genop('xor',w0,w0)
	genop('add',w0,const(1))
	store(w0,arg1)
							:(opdone)

*	1.20 SSL   _opw_	  subroutine stack load

*	1.21 SSS   _opw_	  subroutine stack store

*	This pair of operations is provided to make possible the use of a
*	local stack to hold subroutine (subroutine) return links for n-type
*	procedures.

*	SSS stores the subroutine stack pointer in _opw_ and SSL loads the
*	subroutine stack pointer from _opw_.

*	By using SSS in the main program or on entry to a procedure which
*	should regain control on occurrence of an ERR or ERB and by use of
*	SSL in the error processing sections the subroutine stack pointer can be
*	restored giving a link stack cleaned up ready for resumed execution.

*	The form of the link stack pointer is undefined in MINIMAL (it is likely
*	to be a private register known to the translator) and the only
*	requirement is that it should fit into a single full word.

*	SSL and SSS are no-ops if no private link stack is not used.

*	A private link stack is not used in the ARM implementation.

*	1.22 RTN define start of routine


*	However it is entered by any type of conditional or unconditional
*	branch (not by JSR).

*	On termination it passes control by a branch (often BRI through a code word) or even permits
*	control to drop through to another routine.

*	No return link exists and the end of a routine is not marked by an explicit opcode (compare ENP).

*	All routines must be named in section 0 INR statements.	 

*	#### 2-	 Operations on One Word Integer Values (addresses)


*	2.1	 ADD   _opn,opv_

*	Adds  _opv_ to the value in  _opn_ and stores the result in  _opn_.  Undefined if the result
*	exceeds CFP$L .

g_add

*	optimize after bootstrap

*	isreg(arg1) isreg(arg2)				:s(g_add_reg_reg)
*	isreg(arg1)					:s(g_add_reg_other)
	fetch(w1,arg1)
	fetch(w2,arg2)
	genop('add',w1,w1,w2)
	store(w1,arg1)					:(opdone)

g_add_reg_reg

	genop('add',text(arg1),text(arg2))		:(opdone)

g_add_reg_other

	fetch(w1, arg1)	
	genop('add',text(arg1),text(arg1),w1)		:(opdone)

*	2.2	 SUB   _opn,opv_

*	Subtracts _opv_ from _opn_, and stores the result in _opn_. Undefined if the result is negative.

g_sub

*	optimize after bootstrap

*	isreg(arg1) isreg(arg2)				:s(g_sub_reg_reg)
*	isreg(arg1)					:s(g_sub_reg_other)
	fetch(w1,arg1)
	fetch(w2,arg2)
	genop('sub',w1,w1,w2)				:(opdone)

g_sub_reg_reg

	genop('sub',text(arg1),text(arg2))		:(opdone)

g_sub_reg_other

	fetch(w1,arg2)
	genop('sub',text(arg1),text(arg1),w2)			:(opdone)


*	2.3	 ICA   _opn_


*	Increment address in  _opn_ *	Equivalent to ADD  _opn_,*unity

g_ica	

	fetch(w1,arg1)
	genop('add',w1,const('cfp_b'))
	store(w1,arg1)					:(opdone)

*	2.4	 DCA   _opn_

*	Decrement address in _opn_ equivalent to SUB _opn_,*unity

g_dca

	fetch(w1,arg1)
	genop('sub',w1,const('cfp_b'))
	store(w1,arg1)					:(opdone)


*	The following instructions compare two address values as unsigned integer values.
*	The BLO and BHI instructions are used in cases where the equal condition either does not occur
*	or can result either in a branch or no branch.

*	This avoids inefficient translations in some implementations.

*	2.5	 BEQ   _opn,opv,plbl_

*	Branch to _plbl_  _opn_ eq  _opv_

g_beq	cond = 'eq'					:(g_bop)

*	2.6	 BNE   _opn,opv,plbl_

*	Branch to _plbl_  _opn_ ne  _opv_

g_bne	cond = 'ne'					:(g_bop)

*	2.7	 BGT   _opn,opv,plbl_

*	Branch to _plbl_  _opn_ gt  _opv_

g_bgt	g_bop = 'gt'					:(g_bop)

*	2.8	 BGE   _opn,opv,plbl_

g_bge	g_bop = 'ge'					:(g_bop)

*	Branch to _plbl_  _opn_ ge  _opv_

*	2.9	 BLT   _opn,opv,plbl_

g_blt	g_bop = 'lt'					:(g_bop)

*	Branch to _plbl_  _opn_ lt  _opv_

*	2.10 BLE   _opn,opv,plbl_

g_ble	g_bop = 'le'					:(g_bop)

*	Branch to _plbl_  _opn_ le  _opv_

*	2.11 BLO   _opn,opv,plbl_

*	Equivalent to BLT or BLE

g_blo	g_bop = 'lo'					:(g_bop)

*	2.12 BHI   _opn,opv,plbl_

*	Equivalent to BGT or BGE

g_bhi	g_bop = 'hi'					:(g_bop)

g_bop

	fetch(w1,arg1)
	fetch(w2,arg2)
	genop('cmp',w1,w2)
	jump(bop,arg3)					:(opdone)

*	2.13 BNZ   _opn,plbl_

*	Equivalent to BNE  _opn_,=zeroe,_plbl_

*	2.14 BZE   _opn,plbl_

*	Equivalent to BEQ  _opn_,=zeroe,_plbl_

g_bnz

	fetch(w1,arg1)
	genop('adr',text(arg3))
	genop('ors',w1,w1)
	jump('ne',arg2)					:(opdone)

g_bze	

	fetch(w1,arg1)
	genop('ors',w1,w1)
	jump('eq',arg2)					:(opdone)

*	2.15 LCT  _w,opv_

*	Load counter for BCT

*	LCT loads a counter value for use with the BCT instruction. The value in _opv_ is the number
*	of loop operations to be executed.

*	The value in _w_ after this operation is an undefined one word integer quantity.

g_lct

*	if operands differ must emit code

	differ(text(arg1),text(arg2))			:s(g_lct.1)

*	here if operands same. emit no code if no label, else emit null

	ident(thislabel)				:s(opnext)
	genop()						:(opdone)

g_lct.1

	reg = text(arg1)
	fetch(reg,arg2)					:(opdone)

*	2.16 BCT  _w,plbl_

*	Branch and count

*	BCT uses the counter value in w to branch the required number of times and then finally to fall
*	through to the next instruction.

*	BCT can only be used following an appropriate LCT instruction.

*	The value in _w_ after execution of BCT is undefined.

g_bct

	reg = text(arg1)
	genop('subs',reg,const(1))
	jump('ge',arg2)				:(opdone)

*	2.17 AOV   _opn,opv,plbl_

*	ADD with carry test

*	Adds  _opv_ to the value in  _opn_ and stores result in _opn_.

*	Branches to _plbl_ result exceeds CFP$L with result in	_opn_ undefined. 

g_aov

	fetch(w1,arg1)
	fetch(w2,arg2)
	genop('adds',w1,w1,w2)
	store(w1,arg1)
	jump('cs',arg3)				:(opdone)
o
*	2.18 BEV   _opn,plbl_

*	Branch even

*	2.19 BOD   _opn,plbl_

*	Branch odd

*	These operations are used only .cepp or .crpp is defined.

*	On some implementations, a more efficient implementation is possible by noting that 
*	address of blocks must always be a multiple of CFP$B. We call such addresses even.

*	Thus return address on the stack (.crpp) and entry point addresses (.cepp) can be distinguished 
*	from block addresses they are forced to be odd (not a *	multiple of CFP$B ). 
*	EV and BOD branch according as operand is even or odd, respectively.

*	The instructions are not currently required, and so are not implemented. 
*	See comment for ENT instruction above

g_bev

	error('BEV not supported')			:(opnext)

g_bod

	error('BOD not supported')			:(opnext)

*	 #### 3- Operations on the Code Pointer Register

*	(CP)

*	The code pointer register provides a psuedo instruction counter for use in an interpretor. It may 
*	be implemented as a real register or as a memory location, but in either case it is separate 
*	from any other register.

*	For now, assume CP is in register.

*	3.1	 LCP   _reg_

*	Load code pointer register

*	This instruction causes the code pointer register to be set from the
*	value in _reg_ which is unchanged

g_lcp	

	
	genop('mov',cp,text(arg1))			:(opdone)

*	3.2	 SCP   _reg_

*	Store code pointer register this instruction loads the current value in the code pointer 
*	register into reg_ (CP) is unchanged.

g_scp	     

	genop('mov',text(arg1),cp)			:(opdone)

*	3.3	 LCW  _reg_

*	Load next code word

*	This instruction causes the word pointed to by CP to be loaded into the indicated reg_
*	The value in CP is then incremented by one word.

*	Execution of LCW may destroy XL .

g_lcw  

	genop('ldr',w0,cp)
	genop('mov',text(arg1),w0)
	genop('add',cp,cp,const(1))			:(opdone)

*	3.4	 ICP

*	Increment CP  by one word

*	On machines with more than three index registers, CP can be treated simply as an index register.


g_icp	

	genop('add',cp,cp,const(1))			:(opdone)

*	#### 4-	 Operations on Signed Integer Values

*	4.1	 LDI   _ops_

*	Load integer accumulator from  _ops_

g_ldi

	fetch(ia,arg1)					:(opdone)

*	4.2	 ADI   _ops_

*	ADD  _ops_ to integer accumulator

g_adi

	fetch(w1,arg1)
	genop('adds',ia,ia,w1)				:(opdone)

*	4.3	 MLI   _ops_ 

*	Multiply integer accumulator by	 _ops_

g_mli

	fetch(w1,arg1)

*	arm doesn't allow destination register and first operand register to be the same, so
*	swap the order since multiplication is commutative.

	genop('muls',wc,w1,wc)			(opdone)

*	4.4	 SBI   _ops_

*	Subtract  _ops_ from int accumulator

g_sbi

	fetch(w1,arg1)
	genop('subs',ia,ia,w1)				:(opdone)


*	4.5	 DVI   _ops_

*	Divide integer accumulator by  _ops_


g_dvi

*	In ARM V7, signed and unsigned division are avilable in the THUMB instruction set, with
*	the instructions UDIV and SDIV.


*	Call library procedure (cf. int.asm) to check for zero divisor and do the division

* NOTE: We could -- and probably should -- do check for zero by adding suitably large
* integers to force overflow.

*	Further note that check for divide by zero is not needed for bootstrap.

	fetch(w0,arg1)
	genop('sdiv',ia,w0)				:(opdone)

	fetch(w1,arg1)
	genop('sdivs',ia,ia,w1)				:(opdone)

*	4.6	 RMI   _ops_

*	Set integer accumulator to `mod(intacc,_ops_)`

g_rmi


*	Call library procedure (cf. int.asm) to check for zero divisor and do the division

*	Further note that check for divide by zero is not needed for bootstrap.

* TODO g_rmi
	fetch(w0,arg1)
	genop('rmi_')					:(opdone)

	fetch(w1,arg1)
	error ('rmi todo')				:(opdone)

*	4.7	 STI   _ops_

*	Store integer accumulator at  _ops_
	
g_sti
	store(ia,arg1)					:(opdone)

*	4.8	 NGI

*	Negate the value in the integer accumulator (change its sign)

g_ngi

*	Use NEG pseudo-instruction

	genop('neg',ia,ia)				:(opdone)

*	4.9	 INO  _plbl_

*	Jump to _plbl_ if no integer overflow

g_ino

	jump('vc',arg1)					:(opdone)

*	4.10 IOV  _plbl_

*	Jump to _plbl_ if integer overflow

*	These instructions can only occur immediately following an instruction which can cause 
*	integer overflow (ADI, SBI MLI DVI RMI ngi) and test the result of the preceding instruction.

*	IOV and INO may not have labels.

g_iov

	jump('vs',arg1)					:(opdone)

g_nov

	jump('vc',arg1)					:(opdone)


*	4.11 IEQ  _plbl_

g_ieq	cond = 'eq'					:(g_ia)

*	Jump to _plbl_ if (IA) eq 0

*	4.12 IGE  _plbl_

g_ige	cond = 'ge'					:(g_ia)

*	Jump to _plbl_ if (IA) ge 0

*	4.13 IGT  _plbl_

g_igt	cond = 'gt'					:(g_ia)

*	Jump to _plbl_ if (IA) gt 0

*	4.14 ILE  _plbl_

*	Jump to _plbl_ if (IA) le 0

g_ile	cond = 'le'					:(g_ia)

*	4.15 ILT  _plbl_

g_ilt	cond = 'lt'					:(g_ia)

*	Jump to _plbl_ if (IA) lt 0

*	4.16 INE  _plbl_

*	Jump to _plbl_ if (IA) ne 0

g_ine	cond = 'ne'					:(g_ia)

*	The above conditional jump instructions do not change the contents of the accumulator.

g_ia

	genop('ors',ia,ia,ia)
	jump(cond,arg1)					:(opdone)



*	 #### 5- Operations on Real Values 

*	Real arithmetic not supported for bootstrap version

*	5.1	 LDR   _ops_

*	Load real accumulator from  _ops_

*	5.2	 STR   _ops_

*	Store real accumulator at  _ops_


*	5.3  ADR	_ops_

*	ADD  _ops_ to real accumulator

*	5.4	 SBR   _ops_

*	Subtract  _ops_ from real accumulator


*	5.5	 MLR   _ops_

*	Multiply real accumulator by  _ops_

*	5.6	 DVR   _ops_

*	Divide real accumulator by  _ops_

*	If the result of any of the above operations causes underflow, the result yielded is 0.0.

*	The result of any of the above operations is undefined or out of range, real overflow is set,
*	the contents of (RA) are undefined and the following instruction must be either ROV or RNO.

*	Particular care may be needed on target machines having distinct overflow and divide by zero conditions.

g_ldr
g_str
g_adr
g_sbr
g_mlr
g_dvr

	error('real operation ' incode ' not supported for bootsrap')	:(opdone)

*	5.7	 ROV  _plbl_

*	Jump to _plbl_ real overflow

*	5.8	 RNO  _plbl_

*	Jump to _plbl_ no real overflow

*	These instructions can only occur immediately following an instruction which can cause real 
*	overflow (ADR,SBR MLR DVR.

g_rov
g_rno

	error('real operation ' incode ' not supported for bootsrap')	:(opdone)

*	5.9 NGR

*	Negate real accumulator (change sign)

*g_ngr 

	error('real operation ' incode ' not supported for bootsrap')	:(opdone)
							:(opdone)
*	5.10 REQ  _plbl_

*	Jump to _plbl_ if (RA) eq 0.0

*	5.11 RGE  _plbl_

*	Jump to _plbl_ if (RA) ge 0.0

*	5.12 RGT  _plbl_

*	Jump to _plbl_ if (RA) gt 0.0


*	5.13 RLE  _plbl_

*	Jump to _plbl_ if (RA) le 0.0

*	5.14 RLT  _plbl_

*	Jump to _plbl_ if (RA ) lt 0.0

*	5.15 RNE  _plbl_

*	Jump to _plbl_ if (RA) ne 0.0

*	The above conditional instructions do not affect the value stored in the real accumulator.

g_req	jop = 'je'					:(g_r1)
g_rne	jop = 'jne'					:(g_r1)
g_rge	jop = 'jge'					:(g_r1)
g_rgt	jop = 'jg'					:(g_r1)
g_rle	jop = 'jle'					:(g_r1)
g_rlt	jop = 'jl'

g_r1	

	error('real operation ' incode ' not supported')	:(opdone)
	genop('call','cpr_')

	genop('mov','al','byte [reg_fl]')
	genop('or','al','al')
	genop(jop,getarg(arg1))				:(opdone)

*	5.16 ATN

*	Arctangent of real accumulator

*	5.17 CHP

*	Integer portion of real accumulator

*	5.18 COS

*	Cosine of real accumulator

*	5.19 ETX

*	e to the power in the real accumulator

*	5.20 LNF

*	Natural logorithm of real accumulator

*	5.21 SIN

*	Sine of real accumulator

*	5.22 SQR

*	square root of real accumulat

*	5.23 TAN

*	Tangent of real accumulator


*	The above orders operate upon the real accumulator, and replace the contents of the 
*	accumulator with the result.

*	The result of any of the above operations is undefined or out of range, real overflow is set,
*	the contents of (RA) are undefined and the following instruction must be either ROV or RNO

g_atn
g_chp
g_cos
g_etx
g_lnf
g_sin
g_sqr
g_tan

	error('real operation ' incode ' not supported')	:(opdone)
	genop('call',op_)
							:(opdone)

*	#### 6-	 Operations on Character Values


*	Character operations employ the concept of a character pointer which
*	uses either index register XR or XL (not XS).

*	A character pointer points to a specific character in a string of
*	characters stored CFP$C chars to a word.

*	The only operations permitted on a character pointer are LCH
*	and SCH. In particular, a character pointer may not even be moved with MOV

*	6.1	 PLC  _x,opv_

*	Prepare ch ptr for LCH CMC MVC,TRC MCB

*	6.2	 PSC  _x,opv_

*	Prepare character pointer for SCH MVC MCB

*	_opv_ can be omitted it is zero.

*	The character initially addressed is determined by the word address in _x_ and 
*	the integer offset _opv_.

*	There is an automatic implied offset of CFP$F bytes.  CFP$F is used to formally introduce 
*	into MINIMAL a value needed in translating these opcodes which, since MINIMAL itself 
*	does not prescribe a string structure in detail, depends on the choice of a 
*	data structure for strings in the MINIMAL program.  e.g_ CFP$B =
*	CFP$C = 3, CFP$F = 6, num01 = 1, XL points to a series of 4 words, abc/def/ghi/jkl,
*	then PLC XL ,=num01 points to h.

g_plc
g_psc

	fetch(w1,arg1)
	eq(type(arg2)) 	genop('xor',w2,w2);* no opv
	ne(type(arg2)) 	fetch(w2,arg2)
	genop('add',w1,w1,w2,'cfp_f')			
	store(w1,arg1)					:(opdone)

*	6.3	 LCH  _reg,opc_

*	Load character into register

g_lch

	fetch(text(arg1),arg2,'char')			:(opdone)

*	6.4	 SCH  _reg,opc_

*	Store character from _reg_

*	These operations are defined such that the character is right justified in register 
*	_reg_ with zero bits to the left.

g_sch

	store(text(arg1),arg2,'char')			:(opdone)

*	6.5	 CSC  _x_

*	Complete store characters

*	This instruction marks completion of a PSC sch,SCH ...,sch sequence initiated by a
*	PSC x instruction.

*	No more SCH instructions using x should be obeyed until another PSC is obeyed.

*	It is provided solely as an efficiency aid on machines without character orders since it 
*	permits use of register buffering of chars in sch sequences.

*	Where CSC is not a no-op, it must observe restriction 2. (e.g_ in SPITBOL, *alocs* 
*	zeroises the last word of a string frame prior to SCH sequence being started so CSC 
*	must not nullify this action.)

g_csc	

							:(opdone)

*  ## CEQ and CNE

*	The following instructions are used to compare two words containing CFP$C characters.

*	Comparisons distinct from BEQ BNE are provided as on some target machines, the possibility 
*	of the sign bit being set may require special action.

*	Note that restriction 2 above, eases use of these orders in testing complete strings for 
*	equality, since whole word tests are possible.

*	6.6	 CEQ   _opw,opw,plbl_

*	Jump to _plbl_ if _opw_ eq  _opw_

g_ceq

	fetch(w1,arg1)
	fetch(w2,arg2)
	genop('cmp',w1,w2)
	jump('eq',arg3)					:(opdone)

*	6.7	 CNE   _opw,opw,plbl_

*	Jump to _plbl_	if _opw_ ne  _opw_

g_cne

	fetch(w1,arg1)
	fetch(w2,arg2)
	genop('cmp',w1,w2)
	jump('ne',arg3)					:(opdone)

*	6.8	 CMC  _plbl_,_plbl_

*	Compare characters

*	CMC is used to compare two character strings. CMC registers are set up as follows.

*	```
*		    (XL)	     character ptr for first string
*		    (XR)	     character pointer for second string
*		    (WA)	     character count (must be .gt. zero)
*	```

*	XL and XR should have been prepared by PLC control passes to first _plbl_ the first string is 
*	lexically less than the second string, and to the second _plbl_ the first string is lexically greater.

*	Control passes to the following instruction if the strings are identical. After executing this 
*	instruction, the values of XR and XL are set to zero and the value in (WA) is undefined.

*	Arguments to CMC may be complete or partial strings, so making optimisation to use whole word 
*	comparisons difficult (dependent in general on shifts and masking).

g_cmc

	loop_lbl = genlab()
	done_lbl = genlab()
	
	genopl(looplbl,'nop')
	fetch(w1,arg_xlp,'char')
	fetch(w2,arg_xrp,'char')
	genop('cmp',w1,w2)
	jump('lt',arg1)
	jump('gt',arg2)
	genop('subs',wa,const(1))
	jump('ne',loop_lbl);* loop back if more characters

*	Here if same, so clear xl and xr, then fall through to next instruction

	genopl(done_lbl)
	genop('xor',xl,xl)
	genop('xor',xr,xr)
							:(opdone)

*	6.9	 TRC

*	Translate characters

*	TRC is used to translate a character string using a supplied translation table.
*	Before executing _TRC_ the registers are set as follows.

*	```
*		    (XL)	     char ptr to string to be translated
*		    (XR)	     char ptr to translate table
*		    (WA)	     length of string to be translated
*	```

*	XL and XR should have been prepared by PLC  The translate table consists of CFP$A 
*	contiguous characters giving the translations of the CFP$A characters in the alphabet.

*	On completion, (XR) and (XL) are set to zero and (WA) is undefined.

g_trc

	loop_lbl = genlab()
	done_lbl = genlab()
	fetch(w2,arg_xri,'char');*char ptr to translate table
	
	genopl(loop_lbl)
		fetch(w1,arg_xlp);* next char
		genop('add',w2,w2,w1);* replacement character
		store(w2,arg_xli,'char')
		genop('subs',wa,const(1))
		jump('ne',loop_lbl);* loop back if more characters
	
*	Here when done, so clear xl and xr, then fall through to next instruction

	genopl(done_lbl)
	genop('xor',xl,xl)
	genop('xor',xr,xr)
							:(opdone)
*	6.10 FLC  _w_

*	Fold character to upper case

g_flc

	error('flc  not supported ')			:(opdone)

*	#### 7- Operations on Bit String Values

*	7.1	 ANB   _w,opw_

*	And bit string values, result in _w_

g_anb	

	reg = text(arg1)
	fetch(w1,arg2)
	genop('and',reg,reg,w1)				:(opdone)

*	7.2	 ORB   _w,opw_

*	Or bit string values, result in _w_

	reg = text(arg1)
	fetch(w1,arg2)
	genop('or',reg,reg,w1)				:(opdone)

g_orb	

*	7.3	 XOB   _w,opw_

*	Exclusive or bit string values, result in _w_

*	In the above operations, the logical connective is applied separately to each of the CFP$N bits.

g_xob	

	reg = text(arg1)
	fetch(w1,arg2)
	genop('eor',reg,reg,w1)				:(opdone)

*	7.4	 CMB  _w_

*	Complement all bits in _w_

*	This statement is NOT used in Minimal version of SPITBOL, so no need to translate it.

g_cmb	

	errror('unexpected/unsupported use of cmb operator')	:(opdone)

*	#### Shift operations

*	The following operations are logical shifts, not arithmetic shifts.

*	7.5	 RSH  _w,val_

*	Right shift _w_ by _val_ bits

g_rsh

	reg = text(arg1)
	fetch(w1,arg2)
	genop('and',reg,reg,w1)				:(opdone)

*	7.6	 LSH  _w,val_

*	Left shift _w_ by _val_ bits

g_lsh

	fetch(w1,arg2)
	genop('lsl',w1,const(text(arg2)))
	genop('mov',text(arg1),w1)			:(opdone)

*	7.7	 RSX  _w,(x)_

*	Right shift _w_ by  number of bits in _x_

g_rsx

	fetch(w1,arg2)
	genop('lsr',w1,const(text(arg2)))
	genop('mov',text(arg1),w1)			:(opdone)


*	7.9	 NZB  _w,plbl_

*	Jump to _plbl_ w is not all zero bits.

g_nzb	
	
	reg = text(arg1)
	genop('or',reg,reg)
	jump('ne',arg2)					:(opdone)

*	7.10 ZRB  w,_plbl_

*	Jump to _plbl_ w is all zero bits

g_zrb
	reg = text(arg1)
	genop('or',reg,reg)
	jump('eq',arg1)					:(opdone)

*	7.11 ZGB   _opn_

*	Zeroise garbage bits

*	_opn_ contains a bit string representing a word of characters from a string or 
*	some function formed from such characters (e.g_ as a result of hashing).

*	 On a machine where the word size is not a multiple of the character size,
*	 some bits in _reg_ may be undefined.

*	This opcode replaces such bits by the zero bit. ZGB is a no-op the word size is a
*	multiple of the character size.

g_zgb

	genop('nop')
							:(opdone)

*	#### 8-	 Conversion Instructions


*	The following instructions provide for conversion between lengths in bytes and lengths in words.


*	8.1	 WTB  _reg_

*	Convert	 _reg_ from words to bytes.

*	That is, multiply by CFP$B . This is a no-op if CFP$B  is one.

g_wtb	

	genop('lsl',text(arg1), const('log_cfp_b'))	:(opdone)

*	8.2	 BTW  _reg_

*	Convert _reg_ from bytes to words by dividing _reg_ by CFP$B discarding the fraction.
*	This is a  no-op if CFP$B is one

*	The following instructions provide for conversion of one word integer values (addresses) 
*	to and from the full signed integer format.

g_btw	

	genop('lsr',text(arg1), const('log_cfp_b'))	:(opdone)

*	8.3	 MTI   _opn_

*	The value of _opn_ (an address) is moved as a positive integer to the integer accumulator.

g_mti	

	fetch(w0,arg1);* load address
	genop('ldr',ia, '[' w0 ']')			:(opdone)

*	8.4	 MFI   _opn,plbl_

*	The value currently stored in the integer accumulator is moved to _opn_ as an address 
*	if it is in the range 0 to CFP$M inclusive.

*	If the accumulator value is outside this range, then the result in _opn_ 
*	is undefined and control is passed to _plbl_.

*	MFI destroys the value of (IA) whether or not integer overflow is signalled.  
*	_plbl_ may be omitted overflow is impossible.

*	The following instructions provide for conversion between real values and integer values.

g_mfi

*	last arg is optional
*	compare with cfp$m, branching if result negative

	eq(type(arg2))					:s(g_mfi.1)

*	here if label given, branch if ia not in range (ie, negative)

	genop('mov',ia,w0)
	genop('ors',w0,w0)
	jump('mi',arg2);* branch if ia negative
	genop('subs',w0,w0,const('cfp_m'));
	jump('mi',arg2);* branch if ia greater than cfp_m
	store(ia,arg1)					:(opdone)

g_mfi.1

*	Here if no label given, so just update value of IA.

	store(ia,arg1)					:(opdone)

*	8.5	 ITR

*	Convert integer value in integer accumulator to real and store in real accumulator 
*	(may lose precision in some cases)

g_itr

	error('g_itr real arithmetic not supported')	:(opdone)

*	8.6	 RTI  _plbl_

*	Convert the real value in RA to an integer and place result in IA .  Conversion is 
*	by truncation of the fraction - no rounding occurs.

*	Jump to _plbl_ if RA out of range. *RA* is not changed in either case.

*	_plbl_ may be omitted overflow is impossible.

*	The following instructions provide for computing the length of storage required for a text string_

g_rti

	error('g_rti real arithmetic not supported')	:(opdone)

*	here if label given, branch if real too large

	genop('jc',getarg(arg1))				:(opdone)

*	8.8	 CTB  _w,val_

*	CTB is exactly like CTW except that the result is in bytes.

*	The following instructions provide for conversion from integers to and from numeric 
*	digit characters for use in numeric conversion routines. They employ negative integer 
*	values to allow for proper conversion of numbers which cannot be complemented.

g_ctb

	reg = text(arg1)
	genop('add',reg,reg,const('(cfp_b-1)+cfp_b*' text(arg2)))
	genop('and',reg,const('-cfp_b'))
							:(opdone)
*	8.9	 CVM  _plbl_

*	Convert by multiplication

*	The integer accumulator, which is zero or negative, is multiplied by 10.  WB contains the 
*	character code for a digit. the value of this digit is then subtracted from the result.

*	The result is out of range, then control is passed to _plbl_ with the result in 
*	(IA) undefined. execution of CVM leaves the result in (WB) undefined.

g_cvm	
	genop('mov',w0,const(10))
	genop('smul',ia,w0)
	genop('subs',ia,wb)
	jump('vs',arg1);* jump on overflow
							:(opdone)

*	8.10 cvd
*HERE
*	Convert by division

*	The integer accumulator, which is zero or negative, is divided by 10.
*	the quotient (zero or negative) is replaced in the accumulator.

*	The remainder is converted to the character code of a digit and placed in
*	WA. For example, an operand of -523 gives a quotient of -52 and a
*	remainder in WA of CH$D3.

g_cvd

	genop('mov',w0,const(10))
	genop('sdiv',ia,w0)

*	compute remainder, complement it, and add to code for digit 0.

	genop('smul',w1,ia,const(10))
	genop('sub',w1,ia,w1);* remainder (is negative or zero)
	genop('or',w2,w2);* clear w2
	genop('rsb',w2,w2,w1);* make remainder positive
	genop('add',wa,w2,'ch_d0');* convert to digit code
							:(opdone)

*	#### 9-	 Block Move Instructions

*	The following instructions are used for transferring data from one area of memory to another
*	in blocks.  They can be implemented with the indicated series of other macro-instructions,
*	but more efficient implementations will be possible on most machines.

*	Note that in the equivalent code sequence shown below, a zero value in WA will move at 
*	least one item, and may may wrap the counter causing a core dump in some implementations.
*	Thus WA should be greater than 0 prior to invoking any of these block move instructions.

*	9.1	 MVC

*	Move characters


*	Before obeying this order WA,XL ,XR should have been set up, the latter two by PLC PSC resp.
*	MVC is equivalent to the sequence

*	```
*			   mov	dumpb,WB
*			   lct	WA,WA
*		    loopc  lch	WB,(XL)+
*			   sch	WB,(XR)+
*			   bct	WA,loopc
*			   csc	XR
*			   mov	WB,dumpb

*	```

*	The character pointers are bumped as indicated and the final value of WA is undefined.

g_mvc
 
	z_suspend = 1

	loopc = genlab()
	fetch(wb,arg_xlp,'char')
	store(wb,arg_xrp,'char')
	genop('str',wb,'dumpb')

	genopl(loopc)
		fetch(wb,arg_xrp,'char')
		store(wb,arg_xlp,'char')
		genop('subs',wa,const(1))
		jump('mi',loopc)
	genop('ldr',wb,'dumpb')

	z_suspend = 0
							:(opdone)

*	9.2  MVW

*		      move words


*	MVW is equivalent to the sequence

*	```
*             loopw  opw  mov  (XR)+,(XL)+
*		     dca  WA		  WA = bytes to move
*		     bnz  WA,loopw

*	```


*	Note that this implies that the value in WA is the length in bytes which is a multiple of CFP$B .

*	The initial addresses in XR,XL are word addresses.

*	As indicated, the final XR and XL values point past the new and old regions of memory respectively.

*	The final value of WA is undefined.  WA, XL and XR must be set up before obeying MVW.


g_mvw

	z_suspend = 1

	loopw = genlab()
		genopl(loopw)
		fetch(w0,arg_xlp)
		store(w0,arg_xrp)
		genop('subs',wa,const('cfp_b'))
		jump('ne',loopw)

	z_suspend = 0
							:(opdone)

*	9.3	 MWB

*	Move words backwards

*	MWB  is equivalent to the sequence

*	```
*		    loopb  mov	-(XL),-(XR)
*			   dca	WA		 WA = bytes to move
*			   bnz	WA,loopb
*	```

*	There is a requirement that the initial value in XL be at least 256 less than the value in XR .

*	The final value of WA is undefined.

*	WA,XL, and XR must be set up before obeying MWB .

g_mwb

	loopb = genlab()
		genopl(loopb)
		fetch(w0,arg_mxr)
		store(w0,arg_mxl)
		genop('subs',wa,const('cfp_b'))
		jump('ne',loopb)			:(opdone)

*	9.4	 MCB

*	Move characters backwards


*	MCB is equivalent to the sequence

*	```
*			   mov	dumpb,WB
*			   lct	WA,WA
*		    loopc  lch	WB,-(XL)
*			   sch	WB,-(XR)
*			   bct	WA,loopc
*			   csc	XR
*			   mov	WB,dumpb
*	```


*	There is a requirement that the initial value in XL be at least 256 less than the value in XR.
*	This allows an implementation in which chunks of 256 bytes are moved forward (IBM 360, ICL 1900).

*	The final value of WA is undefined.  WA, XL, and XR must be set up before obeying MCB

g_mcb


	loopc = genlab()
	gen_plc(arg_xl)
	gen_plc(arg_xr)
	store(wb,'dumpb')
	genopl(loopc)
		fetch(wb,arg_mxl,'char')
		store(wb,arg_mxr,'char')
		genop('subs',wa,const(1))
		jump('mi',loopc)
	fetch(wb,'dumpb')

*	#### 10- Operations Connected with the Stack


*	The stack is an area in memory which is dedicated for use in conjunction with the 
*	stack pointer register (XS). As previously described, it is used by the JSR and EXI
*	instructions and may be used for storage of any other data as required.

*	The stack builds downward in this implementation.

*	The starting stack base address is passed in (XS) at The start of execution.
	During execution it is necessary to make sure that the stack does not overflow.
*	This is achieved by executing the following instruction periodically.

*	10.1 CHK

*	Check stack overflow

*	After successfully executing CHK it is permissible to use up to 100 additional words 
	before issuing another chk thus CHK need not be issued every time the stack is
*	expanded. In some implementations, the checking may be automatic and CHK will have no effect.

g_chk

	fetch(w0,minarg(5,'lowspmin'))
	genop('cmp',xs,w0)
	jump('lo',sec06)				:(opdone)

*	#### 11- Data Generation Instructions

*	The following instructions are used to generate constant values in the constant section 
*	and also to assemble initial values in the working storage section.
*	They may not appear except in these two sections.

*	11.1 DAC  _addr_

*	Assemble address constant.

*	Generates one word containing the specified one word integer value (address).

g_dac

	t1 = type(arg1)
	genopl(thislabel,'.word',text(arg1))		:(decend)

*	11.2 DIC  _integer_

*	Generates an integer value which occupies CFP$I consecutive words.

*	The operand is a digit string with a required leading sign.

g_dic

	genopl(thislabel,'.int',text(arg1))		:(decend)

*	11.3 DRC  _real_

*	Assembles a real constant which occupies CFP$R consecutive words.

*	The operand form must obey the rules for a FORTRAN real constant with the extra 
*	requirement that a leading sign be present.

g_drc

	genop('align',4)
	t1 = text(arg1)
	t1 ? fence "+" = ""
	genopl(thislabel,'.float',t1)			:(opdone)

*	11.4 DTC  _dtext_

*	Define _text_ constant.

*	Text is started and ended with any character not contained in the characters to be 
*	assembled. The constant occupies consecutive words as dictated by the 
*	configuration parameter CFP$C .

*	Any unused chars in the last word are right filled with zeros (i.e. the character whose 
*	internal code is zero).	 The string contains a sequence of letters, digits, blanks and 
*	any of the following special characters.  =,$.(\*)/+-

*	No other characters may be used in a _dtext_ operand.

g_dtc

*	change first and last chars to " (assume / used in source)

* output = 'g_d'
	t1 = text(arg1)
	t1 tab(1) rtab(1) . t2
	t3 = remdr(size(t2),cfp_c)

*	      t2 = "'" t2 "'"
*	append nulls to complete last word so constant length is multiple
*	of word word

	dtc_i = 1
	t4 =

g_dtc.1

	t4 = gt(dtc_i, 1) t4 ","
	t4 = t4 "'" substr(t2,dtc_i,1) "'"
	le(dtc_i = dtc_i + 1, size(t2))			:s(g_dtc.1)

	t4 = ne(t3) t4 dupl(',0',cfp_c - t3)
	genopl(thislabel,'.ascii',t4)
							:(opdone)
*	11.5 DBC  _val

*	Assemble bit string constant.

*	The operand is a positive integer value which is interpreted in binary, 
*	right justified and left filled with zero bits. Thus 5 would imply the bit string value 00...101.  

g_dbc

	genopl(thislabel,'.word',text(arg1))		:(opdone)

decend

*	here at end of dic or dac to see if want label made public

	thislabel ? rtab(1) . thislabel '		:'
*	differ(pubtab[thislabel]) genop('.globl',thislabel)
							:(opdone)

*	#### 12- Symbol Definition Instructions

*	The following instruction is used to define symbols in the definitions section.
*	 It may not be used elsewhere.

*	12.1 EQU  _eqop_

*	Define symbol

*	The symbol which appears in the label field is defined to have the absolute value given by the _eqop_ operand.
*	A given symbol may be defined only once in this manner, and any symbols occuring in _eqop_ 
*	must be previously defined.

g_equ

	genop('.set',thislabel ',' , text(arg1))	:(opdone)

*	12.2 _exp_

*	Define external procedure

*	_xp_ defines the symbol appearing in the label field to be the name of an external 
*	procedure which can be referenced in a subsequent JSR instruction.

*	The coding for the procedure is external to the coding of the source program in this language.
*	The code for external procedures may be referred to collectively as the operating system 
*	interface, or more briefly, osint, and will frequently be a separately compiled segment
*	of code loaded with SPITBOL to produce a complete system.

g_exp

	ppm_cases[thislabel] = text(arg1)
	genop('.extern',thislabel)
	thislabel =					:(opdone)

*	12.3 INP  _ptyp,int_

*	Define internal procedure

*	INP defines the symbol appearing in the label field to be the name of 
*	an internal procedure and gives its type and number of exit parameters.

*	The label can be referenced in JSR instructions and it must appear
*	labelling a PRC instruction in the program section.

g_inp

	ppm_cases[thislabel] = text(arg2)
	prc.count1 = ident(text(arg1),'n') prc.count1 + 1 :(opnext)

*	12.4 INR

*	Define internal routine

*	INR defines the symbol appearing in the label field to be the name of an internal routine.

*	The label may be referenced in any type of branch order and it must 
*	appear labelling a RTN instruction in the program section.


g_inr	genop('')					:(opdone)

*	### 13 - Assembly Listing Layout Instruction

*	Who uses listings these days? Who even knows what a listing is? Those were the days ...

*	13.1 EJC

*	Eject to next page

g_ejc							:(opdone)

*	13.2 TTL  text

*	Set new assembly title

*	TTL implies an immediate eject of the assembly listing to print the new title.

*	The use of TTL and EJC cards is such that the program will list neatly the printer prints
*	as many as 58 lines per page. In the event that the printer depth is less than this, or the
*	listing contains interspersed lines (such as actual generated code), then the format may be upset.

*	Who uses listings anymore? Those were the days ...

g_ttl							:(opdone)

end
